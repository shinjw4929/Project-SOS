# Project-SOS 코드 참조 및 설명 문서

이 문서는 프로젝트의 모든 스크립트 파일에 대한 상세한 설명과 참조 관계를 정리한 것입니다.

---

## 📁 Shared/Data - 공유 데이터

### Components/Core/Player.cs
**타입**: `IComponentData`
**네트워크 동기화**: `[GhostField]` - TeamId 동기화

**설명**:
- 플레이어 유닛을 식별하는 핵심 컴포넌트
- `TeamId` 필드로 팀 구분 (NetworkId 기반)

**참조되는 곳**:
- `GoInGameServerSystem.cs:56` - 서버에서 TeamId 설정
- `UnitSelectionSystem.cs:76-82` - 클라이언트에서 팀 확인 후 선택
- `SelectionVisualizationSystem.cs:25` - Player 유닛만 색상 변경

**관련 컴포넌트**:
- `Selected` - 선택 상태와 함께 사용
- `MoveTarget` - 이동 명령과 함께 사용
- `GhostOwner` - 네트워크 소유권

**Authoring**:
- `PlayerAuthoring.cs:18` - Player 컴포넌트 베이킹

---

### Components/Core/Selected.cs
**타입**: `IComponentData`, `IEnableableComponent`
**네트워크 동기화**: ❌ (클라이언트 로컬 전용)

**설명**:
- 유닛의 선택 상태를 나타내는 컴포넌트
- `IEnableableComponent`로 Enable/Disable만으로 빠른 토글 가능
- 클라이언트마다 독립적으로 관리 (네트워크 동기화 안 함)

**참조되는 곳**:
- `UnitSelectionSystem.cs:87-88` - 단일 클릭 시 선택
- `UnitSelectionSystem.cs:142-143` - 박스 드래그 시 선택
- `UnitSelectionSystem.cs:149-154` - 선택 해제 (DeselectAll)
- `SelectionVisualizationSystem.cs:22-29` - 선택 상태에 따라 색상 변경
- `RTSCommandInputSystem.cs:40` - 선택된 유닛에만 이동 명령 적용

**관련 컴포넌트**:
- `Player` - Player 유닛만 선택 가능
- `GhostOwnerIsLocal` - 내 유닛만 선택 가능

**Authoring**:
- `SelectedAuthoring.cs:16-19` - Selected 컴포넌트 베이킹 (초기: 비활성)

---

### Components/Movement/MoveTarget.cs
**타입**: `IComponentData`
**네트워크 동기화**: `[GhostComponent]` + `[GhostField]` (position, isValid)

**설명**:
- 유닛의 이동 목표 지점을 저장하는 컴포넌트
- `position`: 목표 위치 (float3)
- `isValid`: 목표가 유효한지 여부 (도착하면 false)

**참조되는 곳**:
- `NetcodePlayerMovementSystem.cs:27-43` - 명령에서 목표 설정
- `NetcodePlayerMovementSystem.cs:46-89` - 목표를 향해 이동
- `RTSCommandInputSystem.cs:38-39` (주석) - InputState로 대체됨

**관련 컴포넌트**:
- `RTSCommand` - 명령 버퍼에서 목표를 읽어옴
- `LocalTransform` - 실제 위치 업데이트

**Authoring**:
- `MoveTargetAuthoring.cs:17` - MoveTarget 컴포넌트 베이킹

---

### Components/Selection/SelectionBox.cs
**타입**: `IComponentData` (싱글톤)
**네트워크 동기화**: ❌ (클라이언트 로컬 전용)

**설명**:
- 마우스 드래그 박스 선택을 위한 데이터 저장
- `startScreenPos`: 드래그 시작 화면 좌표
- `currentScreenPos`: 현재 마우스 화면 좌표
- `isDragging`: 드래그 중인지 여부

**참조되는 곳**:
- `UnitSelectionInputSystem.cs:22-28` - 싱글톤 엔티티 생성
- `UnitSelectionInputSystem.cs:41-72` - 마우스 입력으로 데이터 갱신
- `UnitSelectionSystem.cs:111-118` - 박스 범위 계산
- `SelectionBoxRenderer.cs:44-55` - UI 렌더링용 데이터 읽기

**관련 컴포넌트**:
- `SelectionState` - 현재 선택 모드와 함께 사용

---

### Components/NetcodePlayerInput.cs
**타입**: `IInputComponentData`
**네트워크 동기화**: ✅ (자동 동기화)

**설명**:
- **현재 사용되지 않음** (WASD 이동 방식에서 RTS 방식으로 전환됨)
- `inputVector`: WASD 입력 벡터 (float2)

**사용 상태**: ⚠️ **Deprecated** - RTSInputState로 대체됨

---

### Components/RTSInputState.cs
**타입**: `IComponentData`
**네트워크 동기화**: ❌ (클라이언트 로컬 전용)

**설명**:
- 클라이언트의 현재 입력 상태를 임시로 저장하는 컴포넌트
- `targetPosition`: 우클릭으로 지정한 목표 위치
- `hasTarget`: 목표가 설정되었는지 여부
- RTSCommand 생성 전에 입력을 기억하는 역할

**참조되는 곳**:
- `RTSCommandInputSystem.cs:39-47` - 우클릭 시 InputState 갱신
- `RTSCommandInputSystem.cs:58-71` - InputState → RTSCommand 변환

**관련 컴포넌트**:
- `RTSCommand` - InputState를 명령으로 변환
- `MoveTarget` - 서버에서 최종적으로 목표 설정

**Authoring**:
- `MoveTargetAuthoring.cs:23` - RTSInputState 컴포넌트 베이킹

---

### Commands/RTSCommand.cs
**타입**: `ICommandData` (네트워크 명령 버퍼)
**네트워크 동기화**: ✅ (자동 동기화)

**설명**:
- RTS 명령을 네트워크로 전송하기 위한 구조체
- `Tick`: 네트워크 틱 (명령 실행 시점)
- `commandType`: 명령 타입 (None, Move)
- `targetPosition`: 명령 대상 위치

**참조되는 곳**:
- `NetcodePlayerMovementSystem.cs:29` - 명령 버퍼 읽기
- `NetcodePlayerMovementSystem.cs:36-42` - Move 명령 처리
- `RTSCommandInputSystem.cs:58-71` - 명령 생성 및 버퍼에 추가

**관련 컴포넌트**:
- `RTSInputState` - 입력 상태에서 명령 생성
- `MoveTarget` - 명령이 실행되면 목표 설정

**Authoring**:
- `MoveTargetAuthoring.cs:20` - RTSCommand 버퍼 베이킹

---

### References/EntitiesReferences.cs
**타입**: `IComponentData` (싱글톤)
**네트워크 동기화**: ❌

**설명**:
- 프리팹 엔티티 참조를 저장하는 싱글톤 컴포넌트
- `playerPrefabEntity`: 플레이어 유닛 프리팹 엔티티

**참조되는 곳**:
- `GoInGameServerSystem.cs:15` - RequireForUpdate (필수 조건)
- `GoInGameServerSystem.cs:24-36` - 플레이어 유닛 생성 시 사용

**Authoring**:
- `EntitiesReferencesAuthoring.cs:13-16` - 싱글톤 베이킹

---

### RPC/GoInGameRequestRpc.cs
**타입**: `IRpcCommand`
**네트워크 동기화**: ✅ (RPC)

**설명**:
- 클라이언트가 서버에 게임 입장을 요청하는 RPC
- 페이로드 없음 (빈 구조체)

**참조되는 곳**:
- `GoInGameClientSystem.cs:28` - 클라이언트가 RPC 전송
- `GoInGameServerSystem.cs:29` - 서버가 RPC 수신

**동작 흐름**:
1. 클라이언트 연결 → `GoInGameClientSystem` 실행
2. `GoInGameRequestRpc` 전송
3. 서버의 `GoInGameServerSystem`이 수신
4. 서버가 플레이어 유닛 생성

---

### RPC/SimpleRpc.cs
**타입**: `IRpcCommand`
**네트워크 동기화**: ✅ (RPC)

**설명**:
- 테스트용 간단한 RPC
- `value`: 정수 값 전송

**참조되는 곳**:
- `TestNetcodeEntitiesClientSystem.cs:24-28` - T키로 RPC 전송
- `TestNetcodeEntitiesServerSystem.cs:22-30` - 서버가 RPC 수신 및 로그

**사용 상태**: ⚠️ 테스트용 코드

---

## 📁 Shared/Systems - 공유 시스템

### NetcodePlayerMovementSystem.cs
**타입**: `ISystem`
**업데이트 그룹**: `PredictedSimulationSystemGroup`
**실행 환경**: 클라이언트 + 서버 (예측 시뮬레이션)

**설명**:
- RTS 유닛의 이동 로직을 처리하는 핵심 시스템
- 두 단계로 동작:
  1. **명령 처리**: RTSCommand 버퍼에서 Move 명령 읽기 → MoveTarget 설정
  2. **이동 로직**: MoveTarget을 향해 직선 이동, 도착하면 isValid = false

**주요 로직**:
- 높이(Y) 차이 무시 (수평 거리만 계산)
- 오버슈팅 방지 (도착 직전 정확한 위치로 이동)
- 회전 처리 (이동 방향으로 회전)

**쿼리 컴포넌트**:
- `MoveTarget` (RW) - 목표 위치 읽기/쓰기
- `LocalTransform` (RW) - 위치 및 회전 업데이트
- `RTSCommand` (버퍼) - 명령 읽기
- `Simulate` (필터) - 시뮬레이션 대상만

**참조 컴포넌트**:
- `RTSCommand:36-42` - Move 명령에서 목표 추출
- `MoveTarget:40-41, 60, 74` - 목표 설정 및 유효성 업데이트
- `LocalTransform:73, 80, 85` - 위치 및 회전 변경

---

## 📁 Client/Data - 클라이언트 데이터

### SelectionState.cs
**타입**: `IComponentData` (싱글톤)
**네트워크 동기화**: ❌ (클라이언트 로컬 전용)

**설명**:
- 현재 선택 모드를 저장하는 싱글톤
- `mode`: Idle, SingleClick, BoxDragging

**참조되는 곳**:
- `UnitSelectionInputSystem.cs:19-20` - 싱글톤 엔티티 생성
- `UnitSelectionInputSystem.cs:40-74` - 마우스 입력으로 모드 변경
- `UnitSelectionSystem.cs:33-42` - 모드에 따라 선택 처리 분기

**모드 설명**:
- `Idle`: 대기 상태
- `SingleClick`: 단일 클릭 (짧은 드래그)
- `BoxDragging`: 박스 드래그 중

---

## 📁 Client/MonoBehaviours - 클라이언트 MonoBehaviour

### SelectionBoxRenderer.cs
**타입**: `MonoBehaviour`
**용도**: UI 렌더링

**설명**:
- 드래그 박스 선택 시 UI로 박스를 그리는 컴포넌트
- ECS 월드에서 `SelectionBox` 싱글톤을 읽어와서 `RectTransform` 업데이트
- Netcode 멀티 월드 환경에서 Client World를 안전하게 찾음

**주요 동작**:
1. `TryInitClientWorld()` - Client World 찾기
2. `Update()` - SelectionBox 데이터 읽기
3. `UpdateBoxRect()` - RectTransform 위치/크기 업데이트

**참조 ECS 컴포넌트**:
- `SelectionBox:44` - isDragging, startScreenPos, currentScreenPos 읽기

**Unity 컴포넌트**:
- `RectTransform` - 박스 UI

---

## 📁 Client/Systems - 클라이언트 시스템

### GoInGameClientSystem.cs
**타입**: `ISystem`
**업데이트 그룹**: (기본)
**실행 환경**: `ClientSimulation`

**설명**:
- 클라이언트가 서버에 연결되면 자동으로 게임 입장 RPC를 전송
- `NetworkId`는 있지만 `NetworkStreamInGame`이 없는 연결에 대해 실행

**주요 동작**:
1. `NetworkStreamInGame` 컴포넌트 추가 (게임 참여 표시)
2. `GoInGameRequestRpc` 전송

**쿼리 컴포넌트**:
- `NetworkId` (RO) - 클라이언트 ID
- `WithNone<NetworkStreamInGame>` - 아직 게임에 참여하지 않은 연결

**참조 RPC**:
- `GoInGameRequestRpc:28` - RPC 생성 및 전송

---

### UnitSelectionInputSystem.cs
**타입**: `ISystem`
**업데이트 그룹**: `GhostInputSystemGroup`
**실행 환경**: `ClientSimulation`

**설명**:
- 마우스 좌클릭/드래그 입력을 감지하는 시스템
- `SelectionState`, `SelectionBox` 싱글톤 생성 및 업데이트

**주요 동작**:
1. 좌클릭 누름 → 드래그 시작 (BoxDragging 모드)
2. 드래그 중 → currentScreenPos 업데이트
3. 좌클릭 해제 → 드래그 거리 판단
   - 짧으면 SingleClick 모드
   - 길면 Idle 모드 (박스 선택 완료)

**쿼리 컴포넌트**:
- `SelectionState` (싱글톤 RW) - 모드 변경
- `SelectionBox` (싱글톤 RW) - 드래그 데이터 업데이트

**입력**:
- `Mouse.current` - 마우스 입력

---

### UnitSelectionSystem.cs
**타입**: `ISystem`
**업데이트 그룹**: `PresentationSystemGroup`
**실행 환경**: `ClientSimulation`

**설명**:
- 선택 모드에 따라 실제 유닛 선택/해제를 처리하는 시스템
- 레이캐스트로 유닛 검출 (Physics 기반)
- 팀 확인 (내 팀만 선택 가능)

**주요 동작**:
- **SingleClick 모드**:
  1. 마우스 위치에서 레이캐스트
  2. 유닛 클릭 → Player 컴포넌트 확인
  3. 팀 확인 (TeamId == myTeamId)
  4. 기존 선택 해제 후 새로 선택
  5. 땅/허공 클릭 → 모든 선택 해제

- **BoxDragging 모드**:
  1. 박스 범위 계산 (min, max)
  2. 모든 유닛의 화면 좌표 계산
  3. 박스 안에 있고 내 팀인 유닛 선택

**쿼리 컴포넌트**:
- `PhysicsWorldSingleton` - 레이캐스트용
- `NetworkId` - 내 팀 ID
- `SelectionState` - 현재 모드
- `Player` - 팀 확인
- `GhostOwnerIsLocal` - 내 유닛만
- `Selected` - 선택 상태 Enable/Disable

**참조 시스템**:
- `EndSimulationEntityCommandBufferSystem` - ECB 사용

---

### RTSCommandInputSystem.cs
**타입**: `ISystem`
**업데이트 그룹**: `GhostInputSystemGroup`
**실행 환경**: `ClientSimulation`

**설명**:
- 마우스 우클릭으로 이동 명령을 입력하는 시스템
- 두 단계로 동작:
  1. **입력 처리**: 우클릭 → RTSInputState 갱신
  2. **명령 생성**: RTSInputState → RTSCommand 버퍼에 추가

**주요 동작**:
1. 우클릭 감지
2. Ground 레이어에 레이캐스트
3. 선택된 내 유닛들의 `RTSInputState` 설정
4. 매 프레임 `RTSInputState` → `RTSCommand` 변환 후 버퍼 추가

**쿼리 컴포넌트**:
- `RTSInputState` (RW) - 입력 상태 갱신
- `RTSCommand` (버퍼) - 명령 추가
- `Selected` (필터) - 선택된 유닛만
- `GhostOwnerIsLocal` (필터) - 내 유닛만

**입력**:
- `Mouse.current` - 마우스 우클릭
- `Camera.main` - 레이캐스트용

---

### SelectionVisualizationSystem.cs
**타입**: `ISystem`
**업데이트 그룹**: `PresentationSystemGroup`
**실행 환경**: `ClientSimulation`

**설명**:
- 선택된 유닛의 색상을 변경하는 시스템
- 선택됨: 초록색 (0, 1, 0)
- 선택 안 됨: 흰색 (1, 1, 1)

**주요 동작**:
1. Player 유닛들 쿼리
2. Selected 컴포넌트 Enable 상태 확인
3. URPMaterialPropertyBaseColor 업데이트
4. 색상이 다를 때만 변경 (최적화)

**쿼리 컴포넌트**:
- `URPMaterialPropertyBaseColor` (RW) - 색상 변경
- `Selected` (RO) - 선택 상태 확인
- `Player` (필터) - Player 유닛만
- `EntityQueryOptions.IgnoreComponentEnabledState` - 비활성 Selected도 읽기

---

### TestNetcodeEntitiesClientSystem.cs
**타입**: `ISystem`
**업데이트 그룹**: (기본)
**실행 환경**: `ClientSimulation`

**설명**:
- 테스트용 시스템
- T키를 누르면 `SimpleRpc` 전송

**사용 상태**: ⚠️ 테스트용 코드

---

## 📁 Server/Systems - 서버 시스템

### GoInGameServerSystem.cs
**타입**: `ISystem`
**업데이트 그룹**: (기본)
**실행 환경**: `ServerSimulation`

**설명**:
- 클라이언트의 게임 입장 요청(`GoInGameRequestRpc`)을 처리하는 서버 시스템
- 플레이어 유닛 생성 및 초기화

**주요 동작**:
1. `GoInGameRequestRpc` 수신
2. `NetworkStreamInGame` 추가 (연결 활성화)
3. 플레이어 유닛 생성 (프리팹 인스턴스화)
4. 랜덤 위치 배치 (-10~10, Y=0)
5. `GhostOwner` 설정 (NetworkId)
6. `Player.TeamId` 설정 (NetworkId와 동일)
7. `LinkedEntityGroup` 추가

**쿼리 컴포넌트**:
- `ReceiveRpcCommandRequest` - RPC 수신
- `GoInGameRequestRpc` - 게임 입장 RPC
- `EntitiesReferences` (싱글톤) - 프리팹 참조

**생성 컴포넌트**:
- `LocalTransform` - 랜덤 위치
- `GhostOwner` - 네트워크 소유권
- `Player` - TeamId 설정

---

### TestNetcodeEntitiesServerSystem.cs
**타입**: `ISystem`
**업데이트 그룹**: (기본)
**실행 환경**: `ServerSimulation`

**설명**:
- 테스트용 시스템
- `SimpleRpc` 수신 시 로그 출력 후 엔티티 제거

**사용 상태**: ⚠️ 테스트용 코드

---

## 📁 Authoring/MonoBehaviours - 오써링 컴포넌트

### Cores/EntitiesReferencesAuthoring.cs
**타입**: `MonoBehaviour` (Baker)
**용도**: 프리팹 레퍼런스 베이킹

**설명**:
- GameObject 프리팹을 Entity로 변환해서 `EntitiesReferences` 싱글톤에 저장
- `playerPrefabGameObject` → `playerPrefabEntity`

**베이킹 컴포넌트**:
- `EntitiesReferences` (싱글톤)

**씬 설정**:
- 씬에 1개만 존재해야 함
- Inspector에서 Player 프리팹 GameObject 할당

---

### Units/PlayerAuthoring.cs
**타입**: `MonoBehaviour` (Baker)
**용도**: Player 유닛 베이킹

**설명**:
- Player 프리팹에 부착
- `Player` 컴포넌트와 색상 컴포넌트 추가

**베이킹 컴포넌트**:
- `Player` - 유닛 식별
- `URPMaterialPropertyBaseColor` - 초기 색상 흰색

---

### Units/MoveTargetAuthoring.cs
**타입**: `MonoBehaviour` (Baker)
**용도**: 이동 관련 컴포넌트 베이킹

**설명**:
- Player 프리팹에 부착
- 이동에 필요한 모든 컴포넌트 추가

**베이킹 컴포넌트**:
- `MoveTarget` - 서버 동기화 목표 (초기: invalid)
- `RTSCommand` (버퍼) - 명령 버퍼
- `RTSInputState` - 클라이언트 입력 상태 (초기: no target)

---

### Units/SelectedAuthoring.cs
**타입**: `MonoBehaviour` (Baker)
**용도**: 선택 컴포넌트 베이킹

**설명**:
- Player 프리팹에 부착
- `Selected` 컴포넌트 추가 (초기: 비활성)

**베이킹 컴포넌트**:
- `Selected` - 선택 상태 (초기: disabled)

---

## 📁 Bootstrap - 게임 부트스트랩

### GameBootStrap.cs
**타입**: `ClientServerBootstrap` (상속)
**용도**: 게임 초기화

**설명**:
- Unity 시작 시 자동 실행
- 클라이언트-서버 환경 설정

**설정**:
- `Application.runInBackground = true` - 백그라운드 실행 허용
- `AutoConnectPort = 7979` - 자동 연결 포트

**실행 순서**:
1. Unity 시작
2. `GameBootStrap.Initialize()` 호출
3. Netcode 월드 생성 (Client + Server)
4. 클라이언트가 자동으로 localhost:7979에 연결

---

## 📊 전체 데이터 흐름

### 연결 흐름
```
1. GameBootStrap 실행 (포트 7979 설정)
2. 클라이언트 자동 연결
3. GoInGameClientSystem → GoInGameRequestRpc 전송
4. GoInGameServerSystem → RPC 수신
5. 서버가 Player 유닛 생성 (GhostOwner, TeamId 설정)
6. 유닛이 Ghost 동기화로 클라이언트에 복제
```

### 선택 흐름 (클라이언트)
```
1. UnitSelectionInputSystem (GhostInputSystemGroup)
   - 마우스 좌클릭/드래그 감지
   - SelectionState, SelectionBox 업데이트

2. UnitSelectionSystem (PresentationSystemGroup)
   - 레이캐스트로 유닛 검출
   - 팀 확인 (Player.TeamId == myTeamId)
   - Selected 컴포넌트 Enable/Disable

3. SelectionVisualizationSystem (PresentationSystemGroup)
   - Selected 상태에 따라 색상 변경
   - 초록색 (선택) / 흰색 (미선택)

4. SelectionBoxRenderer (MonoBehaviour)
   - SelectionBox 데이터 읽기
   - UI RectTransform 업데이트
```

### 이동 명령 흐름 (클라이언트 → 서버)
```
1. RTSCommandInputSystem (GhostInputSystemGroup) - 클라이언트
   - 마우스 우클릭 감지
   - Ground 레이어에 레이캐스트
   - RTSInputState 갱신 (targetPosition, hasTarget)
   - RTSCommand 버퍼에 추가

2. NetcodePlayerMovementSystem (PredictedSimulationSystemGroup) - 클라이언트 + 서버
   [단계 1: 명령 처리]
   - RTSCommand 버퍼에서 Move 명령 읽기
   - MoveTarget 설정 (position, isValid = true)

   [단계 2: 이동 로직]
   - MoveTarget.position 향해 이동
   - 높이(Y) 차이 무시
   - 도착하면 isValid = false

3. Ghost 동기화
   - MoveTarget (서버) → 모든 클라이언트에 복제
   - 클라이언트는 예측 시뮬레이션으로 부드럽게 이동
```

---

## 🔗 컴포넌트 의존성 그래프

### Player (핵심 컴포넌트)
- 의존하는 컴포넌트: 없음
- 사용하는 시스템:
  - `GoInGameServerSystem` - TeamId 설정
  - `UnitSelectionSystem` - 팀 확인
  - `SelectionVisualizationSystem` - Player 필터

### Selected (선택 상태)
- 의존하는 컴포넌트: `Player`
- 사용하는 시스템:
  - `UnitSelectionSystem` - Enable/Disable
  - `SelectionVisualizationSystem` - 색상 변경
  - `RTSCommandInputSystem` - 선택된 유닛만 명령

### MoveTarget (이동 목표)
- 의존하는 컴포넌트: `RTSCommand`
- 사용하는 시스템:
  - `NetcodePlayerMovementSystem` - 목표 설정 및 이동

### RTSInputState (입력 상태)
- 의존하는 컴포넌트: 없음
- 사용하는 시스템:
  - `RTSCommandInputSystem` - 입력 저장 및 명령 생성

### RTSCommand (명령 버퍼)
- 의존하는 컴포넌트: `RTSInputState`
- 사용하는 시스템:
  - `RTSCommandInputSystem` - 명령 추가
  - `NetcodePlayerMovementSystem` - 명령 읽기

### SelectionState (선택 모드)
- 의존하는 컴포넌트: 없음
- 사용하는 시스템:
  - `UnitSelectionInputSystem` - 모드 변경
  - `UnitSelectionSystem` - 모드 읽기

### SelectionBox (드래그 박스)
- 의존하는 컴포넌트: 없음
- 사용하는 시스템:
  - `UnitSelectionInputSystem` - 드래그 데이터 갱신
  - `UnitSelectionSystem` - 박스 범위 읽기
- MonoBehaviour:
  - `SelectionBoxRenderer` - UI 렌더링

---

## 🎯 시스템 실행 순서

### 프레임당 업데이트 순서

**1. GhostInputSystemGroup** (입력 수집)
- `UnitSelectionInputSystem` - 마우스 좌클릭/드래그
- `RTSCommandInputSystem` - 마우스 우클릭 + 명령 생성

**2. PredictedSimulationSystemGroup** (시뮬레이션)
- `NetcodePlayerMovementSystem` - 명령 처리 + 이동

**3. PresentationSystemGroup** (표현)
- `UnitSelectionSystem` - 선택 처리 (레이캐스트)
- `SelectionVisualizationSystem` - 색상 변경

**4. MonoBehaviour.Update** (Unity 기본)
- `SelectionBoxRenderer` - UI 렌더링

---

## 📝 Authoring → Runtime 매핑

### Player 프리팹 구성 (Authoring)
- `PlayerAuthoring` → `Player`, `URPMaterialPropertyBaseColor`
- `MoveTargetAuthoring` → `MoveTarget`, `RTSCommand`, `RTSInputState`
- `SelectedAuthoring` → `Selected`

### 씬 오브젝트 (Authoring)
- `EntitiesReferencesAuthoring` → `EntitiesReferences` (싱글톤)

### 런타임 생성 (Systems)
- `UnitSelectionInputSystem.OnCreate` → `SelectionState`, `SelectionBox` (싱글톤)

---

## 🚨 주의사항

### Deprecated 컴포넌트
- `NetcodePlayerInput.cs` - WASD 이동 방식 (사용 안 함)

### 테스트 전용 코드
- `SimpleRpc.cs` - RPC 테스트용
- `TestNetcodeEntitiesClientSystem.cs` - T키 RPC 전송
- `TestNetcodeEntitiesServerSystem.cs` - RPC 수신 로그

### 네트워크 동기화 주의
- `[GhostField]` 있는 컴포넌트만 동기화됨
- `Selected`, `SelectionState`, `SelectionBox`는 클라이언트 로컬 전용
- `MoveTarget`, `Player.TeamId`, `RTSCommand`는 서버 동기화

---

이 문서는 모든 스크립트 파일의 역할과 참조 관계를 정리한 것입니다.
각 파일의 상단에 이 정보를 주석으로 추가하면 코드 이해가 더 쉬워집니다! 📚
