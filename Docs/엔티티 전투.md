# 엔티티 전투

# 전체 흐름

```
[Client] 우클릭 적 → AttackRequestRpc
    ↓
[Server] HandleAttackRequestSystem → Intent.Attack, AggroTarget 설정
    ↓
[SpatialPartitioningGroup]
SpatialMapBuildSystem → TargetingMap 빌드 (셀 크기: 10.0f)
    ↓
[SimulationSystemGroup]
UnifiedTargetingSystem → 적→아군, 유닛→적 자동 타겟팅 (SpatialMaps.TargetingMap 사용)
    ↓
[FixedStepSimulationSystemGroup]
┌──────────────┼──────────────┐
↓              ↓              ↓
MeleeAttack    RangedAttack   CombatDamage
(근접 공격)    (원거리 공격)   (투사체 충돌)
└──────────────┼──────────────┘
               ↓
        DamageEvent 버퍼 (Attacker 포함)
               ↓
        AggroReactionSystem → 피격 시 어그로 전환
               ↓
        DamageApplySystem → Health 적용 + 버퍼 클리어 + 적 킬 카운트 (GamePhaseState)
               ↓
[SimulationSystemGroup]
HeroDeathDetectionSystem → Hero 사망 감지, UserAliveState 업데이트, HeroDeathRpc/GameOverRpc 전송
               ↓
ServerDeathSystem → Health ≤ 0 삭제 + 인구수 반환
               ↓
[Client] GameOverReceiveSystem → RPC 수신 → UserContext.Dead 전환 + UI 이벤트 발생
```

## 컴포넌트 (Shared/Components/)

| 파일 | 역할 |
| --- | --- |
| CombatStats.cs | 공격력(AttackPower), 공격속도(AttackSpeed), 사거리(AttackRange) |
| Health.cs | 현재 체력(CurrentValue), 최대 체력(MaxValue) |
| Defense.cs  | 방어력 (0.0~1.0, 비율 감소) |
| AttackCooldown.cs | 다음 공격까지 남은 시간 (초) |
| AggroTarget.cs | 공격/추적 대상 엔티티 + 마지막 알려진 위치 |
| AggroLock.cs | 어그로 고정 (LockedTarget, RemainingLockTime, LockDuration) |
| ProjectileMove.cs | 투사체 방향, 속도, 남은 거리 |
| ObstacleRadius.cs | 엔티티 반지름 (거리 판정용) |
| UserAliveState.cs | 유저 생존 상태 (Connection 엔티티에 부착). IsAlive, HeroEntity 포함 |

## 버퍼 (Shared/Buffers/)

| 파일 | 역할 |
| --- | --- |
| DamageEvent.cs | 지연 데미지 기록. Damage + Attacker 포함. 여러 시스템이 Health 직접 수정 시 Job 충돌 방지용. AggroReactionSystem에서 Attacker 정보 읽은 후 DamageApplySystem에서 일괄 적용 |

## 태그 (Shared/Components/Tags/)

| 파일 | 역할 | 적용 대상 |
| --- | --- | --- |
| RangedUnitTag.cs | 원거리 유닛 표시 (MeleeAttackSystem 제외) | Archer, Tank |
| RangedEnemyTag.cs | 원거리 적 표시 (MeleeAttackSystem 제외) | EnemyFlying |
| VisualOnlyTag.cs | 시각 전용 투사체 (데미지 없음, CombatDamageSystem 제외) | 원거리 공격 시 생성 투사체 |

## 서버 시스템 (Server/Systems/)

### 타겟팅 시스템

파일: UnifiedTargetingSystem.cs
그룹: SimulationSystemGroup (UpdateAfter: SpatialPartitioningGroup, HandleAttackRequestSystem, UpdateBefore: PathfindingSystem)
역할: 통합 타겟팅 시스템. SpatialMaps.TargetingMap을 사용하여 공간 분할 기반 탐색.
- EnemyTargetJob: 적→아군 타겟팅 (유닛/건물 탐색, 타겟 없으면 랜덤 배회)
  - 셀 탐색 범위: `ceil(LoseTargetDistance / CellSize)` 동적 계산 (aggroRange가 CellSize보다 큰 경우 대응)
  - 시간 분할: 배회 중(타겟 없음)이면 4프레임에 1번만 탐색, 타겟 상실 시 즉시 탐색
- UnitAutoTargetJob: 유닛→적 자동 감지 (Idle/AttackMove/Attack 상태에서만, Worker 제외)
  - 시간 분할: 유효 타겟 보유 시 4프레임에 1번 "더 가까운 적" 재탐색, 타겟 무효/없음 시 즉시 탐색
  - 타겟 전환 조건: 새 타겟이 기존 타겟보다 가까운 경우에만 전환 (flickering 방지)
- EnemyWanderOnlyJob: SpatialMaps 없을 때 배회 전용 (아래 배회 시스템 참조)
- 최적화: 타겟 고착화(Hysteresis), 시간 분할(Time Slicing)
- **어그로 고정**: AggroLock.RemainingLockTime > 0이면 타겟 변경 불가
- **Partial Path 재시도**: `MovementGoal.IsPathPartial`이면 2초마다 경로 재계산 (ElapsedTime 기반 + 프레임 분산). `MovementGoal.DestinationSetTime`으로 마지막 목적지 설정 시간 추적. 목적지 변경 시 IsPathPartial 리셋. 벽 파괴 등 장애물 변화에 대응.
- **배회 stuck 감지**: 3초마다 이동 거리 체크 (`MovementGoal.LastPositionCheck`, `LastPositionCheckTime`). 2m 미만 이동 시 stuck으로 판정하여 재배회.

---

### 적 배회 시스템 (Enemy Wandering)

**상태**: `EnemyContext.Wandering` (EnemyState.cs)

**트리거 조건**:
- 타겟이 없을 때 (`AggroTarget.TargetEntity == Entity.Null`)
- 현재 상태가 `Wandering`이 아니거나 경로가 없을 때 (`!waypointsEnabled`)

**배회 목적지 결정**:
```csharp
// GridSettings 기반 맵 범위 계산
float2 mapMin = GridSettings.GridOrigin;
float2 mapMax = mapMin + new float2(
    GridSettings.GridSize.x * GridSettings.CellSize,
    GridSettings.GridSize.y * GridSettings.CellSize);

// 랜덤 시드 생성 (황금비 매직넘버로 비트 패턴 혼합)
uint seed = (uint)entity.Index ^ (FrameCount * 0x9E3779B9) ^ (uint)(ElapsedTime * 1000);
var random = Random.CreateFromIndex(seed);

// 목적지: 맵 가장자리에서 5유닛 여유
float3 wanderDest = new float3(
    random.NextFloat(mapMin.x + 5f, mapMax.x - 5f),
    myPos.y,
    random.NextFloat(mapMin.y + 5f, mapMax.y - 5f));
```

**실행 Job**:
| Job | 실행 조건 | 역할 |
|-----|----------|------|
| EnemyTargetJob | SpatialMaps 유효 | 타겟 탐색 실패 시 배회 로직 실행 |
| EnemyWanderOnlyJob | SpatialMaps 없음 | 배회 전용 (맵 빌드 전 fallback) |

**동작 흐름**:
1. 타겟 탐색 실패 → `EnemyContext.Wandering` 전환
2. `MovementGoal.Destination` = 랜덤 목적지
3. `MovementGoal.IsPathDirty` = true
4. `MovementGoal.DestinationSetTime` = ElapsedTime (Partial Path 재시도용)
5. `MovementGoal.LastPositionCheckTime` = ElapsedTime, `LastPositionCheck` = 현재 위치 (stuck 감지용)
6. `MovementWaypoints` 활성화 → PathfindingSystem에서 경로 계산
7. PathFollowSystem에서 이동 실행
8. 목적지 도착 또는 타겟 발견 시 다음 상태로 전환
9. 3초간 2m 미만 이동 시 stuck → 재배회

---

### 전투 시스템 (Server/Systems/Combat/)

파일: HandleAttackRequestSystem.cs
그룹: SimulationSystemGroup
역할: AttackRequestRpc 수신 → 소유권 검증 → UnitIntentState=Attack, AggroTarget 설정, MovementGoal 갱신 (추격 시작)
---
파일: MeleeAttackSystem.cs
그룹: FixedStepSimulationSystemGroup (UpdateAfter: PhysicsSystemGroup)
역할: 근접 공격 처리. 두 개 Job: EnemyMeleeAttackJob(적), UnitMeleeAttackJob(유닛).
- **거리 판정**: 직선거리 - 타겟 반지름(ObstacleRadius) = effectiveDist
- 사거리 내: DamageEvent 추가 (Attacker 포함) + 쿨다운 리셋 + 타겟 방향 회전
- 사거리 밖: 추격 (EnemyContext.Chasing / Action.Moving)
- RangedUnitTag/RangedEnemyTag 제외
---
파일: RangedAttackSystem.cs
그룹: FixedStepSimulationSystemGroup (UpdateAfter: MeleeAttackSystem)
역할: 원거리 공격 처리. IJobEntity + Burst + ECB.ParallelWriter로 병렬 처리.
- RangedUnitAttackJob: RangedUnitTag 유닛 처리 (Archer, Tank)
- RangedEnemyAttackJob: RangedEnemyTag 적 처리 (EnemyFlying)
- 필중 시스템: 거리 판정 후 즉시 DamageEvent 추가 (ECB.AppendToBuffer, Attacker 포함) + 시각 투사체 생성(VisualOnlyTag)
- 사거리 내: 이동 비활성화, 타겟 방향 회전
- 사거리 밖: 추격 (MovementGoal 업데이트)
---
파일: CombatDamageSystem.cs
그룹: PhysicsSystemGroup (UpdateAfter: PhysicsSimulationGroup)
역할: Physics Trigger 기반 투사체 충돌 처리.
- ITriggerEventsJob으로 충돌 감지
- VisualOnlyTag 제외 (시각 투사체는 데미지 없음)
- 충돌 시 DamageEvent 추가 (Attacker=투사체) + 투사체 삭제
- NativeParallelHashSet으로 프레임당 중복 히트 방지
- 아군 히트 방지 (같은 Team은 무시)
---
파일: AggroReactionSystem.cs
그룹: FixedStepSimulationSystemGroup (UpdateAfter: RangedAttackSystem, UpdateBefore: DamageApplySystem)
역할: **피격 시 어그로 반응 시스템 (신규)**
- DamageEvent 버퍼에서 Attacker 정보를 읽어 어그로 전환
- AggroLock.LockDuration 동안 어그로 고정 (RemainingLockTime)
- EnemyAggroReactionJob: 적 어그로 반응 (항상 활성화)
- UnitAggroReactionJob: 유닛 어그로 반응 (사용자 명령 우선)
  - Move, Build, Gather, Hold, Patrol, Attack 상태면 무시
  - Idle/AttackMove 상태에서만 피격 어그로 활성화
  - 어그로 전환 시 Intent.Attack으로 변경
---
파일: DamageApplySystem.cs
그룹: FixedStepSimulationSystemGroup (UpdateAfter: MeleeAttackSystem)
역할: DamageEvent 버퍼 합산 → Health에 적용 → 버퍼 클리어 + 적 킬 카운트.
- **AggroReactionSystem 이후 실행**: Attacker 정보는 이미 처리됨
- 핵심: 모든 데미지 시스템의 결과를 일괄 처리
- **킬 카운트 통합**: 이번 프레임에 사망한 EnemyTag 엔티티를 카운트하여 GamePhaseState.TotalKillCount 갱신 (기존 EnemyDeathCountSystem 통합)
---
파일: HeroDeathDetectionSystem.cs
그룹: SimulationSystemGroup (UpdateBefore: ServerDeathSystem)
역할: Hero 사망 감지 및 게임오버 처리 (ServerDeathSystem에서 Hero 파괴 전 실행)
- Health ≤ 0 + HeroTag인 엔티티 감지
- Connection 엔티티의 UserAliveState.IsAlive = false 설정
- HeroDeathRpc 전송 (해당 유저에게)
- 모든 유저 사망 시 GameOverRpc 브로드캐스트
---
파일: ServerDeathSystem.cs
그룹: SimulationSystemGroup
역할: Health ≤ 0인 엔티티 삭제 (ECB.DestroyEntity) + 인구수 반환 (PopulationEvent)

## 클라이언트 시스템 (Client/Systems/)

파일: ClientDeathSystem.cs
위치: Client/Systems/Combat/
그룹: SimulationSystemGroup
역할: Health ≤ 0인 엔티티에 DisableRendering 추가. 서버 삭제 전까지 렌더링만 끔 (갑작스러운 사라짐 방지)
---
파일: ProjectileVisualSystem.cs
위치: Client/Systems/Combat/
그룹: SimulationSystemGroup
역할: 시각 투사체(VisualOnlyTag) 이동. RemainingDistance 감소 → 0 이하면 삭제. (RPC 미사용, Ghost 복제로 동기화)
---
파일: GameOverReceiveSystem.cs
위치: Client/Systems/
그룹: SimulationSystemGroup
역할: 게임오버 관련 RPC 수신 처리
- HeroDeathRpc 수신 → UserState.CurrentState = UserContext.Dead + GameOverEvents.RaiseHeroDeath()
- GameOverRpc 수신 → GameOverEvents.RaiseGameOver()

## 공간 분할 시스템 (Server/Systems/Spatial/)

파일: SpatialMapBuildSystem.cs
그룹: SpatialPartitioningGroup (OrderFirst=true)
역할: 공간 분할 맵 빌드
- TargetingMap (셀 크기: 10.0f): 타겟팅용 공간 해시맵
- MovementMap (셀 크기: 3.0f): 이동 충돌 회피용 (대형 유닛 AABB 등록)
- Persistent 맵을 매 프레임 Job 기반 Clear 후 재빌드 (CompleteDependency 불필요)
- 결과를 SpatialMaps 싱글톤에 저장

## Shared 시스템 (Shared/Systems/)

파일: ProjectileMoveSystem.cs
그룹: SimulationSystemGroup
역할: 투사체 이동 (서버/클라이언트 공용). Direction * Speed * dt 이동, RemainingDistance 감소

## 유틸리티 (Shared/Utilities/)

| 파일 | 역할 |
| --- | --- |
| DamageUtility.cs | 데미지 계산: finalDamage = baseDamage * (1 - defense). Defense 0.3이면 30% 감소 |

## RPC (Shared/RPCs/)

| 파일 | 역할 |
| --- | --- |
| AttackRequestRpc.cs | 공격 명령 RPC. UnitGhostId, TargetGhostId, TargetPosition 포함 |
| HeroDeathRpc.cs | 서버 → 클라이언트: 해당 유저의 Hero 사망 알림 |
| GameOverRpc.cs | 서버 → 클라이언트: 게임오버 브로드캐스트 (모든 Hero 사망 시) |

## 핵심 설계 포인트

### 1. DamageEvent 버퍼 패턴

DamageEvent 버퍼에 기록 (Attacker 포함) → AggroReactionSystem에서 어그로 처리 → DamageApplySystem에서 일괄 적용 + 버퍼 클리어

```csharp
// 공격 시스템에서 DamageEvent 추가
ECB.AppendToBuffer(sortKey, targetEntity, new DamageEvent
{
    Damage = finalDamage,
    Attacker = attackerEntity  // 어그로 전환용
});
```

### 2. 어그로 고정 패턴 (AggroLock)

피격 시 N초 동안 어그로 대상 변경 불가. UnifiedTargetingSystem에서 체크.

```csharp
// AggroReactionSystem에서 어그로 고정
if (canSwitchTarget)
{
    aggroTarget.TargetEntity = validAttacker;
    aggroLock.LockedTarget = validAttacker;
    aggroLock.RemainingLockTime = aggroLock.LockDuration;  // 고정 시작
}

// UnifiedTargetingSystem에서 고정 체크
if (aggroLock.RemainingLockTime > 0f && aggroLock.LockedTarget != Entity.Null)
{
    // 고정된 타겟 유지, 탐색 스킵
    return;
}
```

### 3. 공격 타입별 처리

| 타입 | 시스템 | 필터 | 데미지 방식 |
| --- | --- | --- | --- |
| 근접 | MeleeAttackSystem | WithNone<RangedUnitTag/RangedEnemyTag> | (직선거리 - 타겟 반지름) ≤ 사거리 → DamageEvent |
| 원거리 | RangedAttackSystem | WithAll<RangedUnitTag/RangedEnemyTag> | 거리 판정 → 즉시 DamageEvent (필중) + 시각 투사체 |
| 투사체 | CombatDamageSystem | Physics Trigger | 충돌 시 DamageEvent |

### 4. 거리 판정 (RTS 스타일)

```csharp
// 직선거리 - 타겟 반지름(ObstacleRadius)
float rawDist = math.distance(myPos, targetPos);
float targetRadius = ObstacleRadiusLookup.TryGetComponent(targetEntity, out ObstacleRadius obstacleRadius)
    ? obstacleRadius.Radius
    : 0f;
float effectiveDist = math.max(0f, rawDist - targetRadius);
bool isInRange = effectiveDist <= combatStats.AttackRange;
```

### 5. 시각 투사체 (원거리 공격)

서버: RangedAttackSystem
→ 데미지 즉시 적용 (필중)
→ 투사체 엔티티 생성 + VisualOnlyTag + ProjectileMove
→ Ghost로 클라이언트 복제

클라이언트: ProjectileVisualSystem
→ 복제된 투사체 이동 표시
→ RemainingDistance ≤ 0 삭제

### 6. 시스템 실행 순서

```
[SpatialPartitioningGroup] ─────────────────────────────
SpatialMapBuildSystem (OrderFirst)
    → TargetingMap 빌드 (셀 크기: 10.0f)
    → MovementMap 빌드 (셀 크기: 3.0f)
    → SpatialMaps 싱글톤에 저장

[SimulationSystemGroup] ─────────────────────────────────
HandleAttackRequestSystem
    ↓ UpdateAfter
UnifiedTargetingSystem (SpatialMaps.TargetingMap 사용)
    ├─ EnemyTargetJob (적→아군 타겟팅, AggroLock 체크)
    ├─ UnitAutoTargetJob (유닛→적 자동 감지, AggroLock 체크)
    └─ EnemyWanderOnlyJob (타겟 없을 때 배회)

[PhysicsSystemGroup] ────────────────────────────────────
PhysicsSimulationGroup
    ↓ UpdateAfter
CombatDamageSystem (투사체 충돌, VisualOnlyTag 제외)

[FixedStepSimulationSystemGroup] ────────────────────────
    ↓ UpdateAfter: PhysicsSystemGroup
MeleeAttackSystem (근접, RangedUnitTag/RangedEnemyTag 제외)
    ↓ UpdateAfter
RangedAttackSystem (원거리, RangedUnitTag/RangedEnemyTag 대상)
    ↓ UpdateAfter
AggroReactionSystem (피격 어그로 반응, DamageEvent.Attacker 읽기)
    ↓ UpdateAfter: MeleeAttackSystem
DamageApplySystem (데미지 적용 + 버퍼 클리어 + 적 킬 카운트)

[SimulationSystemGroup] ─────────────────────────────────
HeroDeathDetectionSystem (UpdateBefore: ServerDeathSystem)
    → Hero 사망 감지 (Health ≤ 0 + HeroTag)
    → UserAliveState.IsAlive = false
    → HeroDeathRpc 전송 (해당 유저)
    → 모든 유저 사망 시 GameOverRpc 브로드캐스트
    ↓
ServerDeathSystem → Health ≤ 0 삭제 + 인구수 반환

[SimulationSystemGroup - Client] ────────────────────────
GameOverReceiveSystem
    → HeroDeathRpc 수신 → UserContext.Dead + GameOverEvents.RaiseHeroDeath()
    → GameOverRpc 수신 → GameOverEvents.RaiseGameOver()

```

### 7. 공간 분할 최적화 기법

| 기법 | 설명 |
| --- | --- |
| 타겟 고착화 (Hysteresis) | LoseTargetDistance = DetectionRange × 1.3배 |
| 시간 분할 - EnemyTargetJob | 배회 중(hadTarget=false): 4프레임 분할. 타겟 상실(hadTarget=true): 즉시 탐색 |
| 시간 분할 - UnitAutoTargetJob | 유효 타겟 보유: 4프레임에 1번 더 가까운 적 재탐색. 타겟 무효/없음: 즉시 탐색 |
| 동적 셀 탐색 범위 | `ceil(range / CellSize)` → aggroRange > CellSize인 경우 셀 경계 누락 방지 |
| 타겟 전환 방지 | UnitAutoTargetJob: 새 타겟이 기존보다 가까운 경우에만 전환 (shouldSwitch) |
| 대형 유닛 AABB | radius > CellSize × 0.5f인 경우 여러 셀에 등록 |
| 해시 충돌 방지 | capacity = entityCount × 1.5f |

### 8. 어그로 반응 조건 (유닛 vs 적)

| 유닛 종류 | 어그로 반응 조건 |
| --- | --- |
| 적 (EnemyTag) | 항상 활성화. 피격 시 공격자에게 어그로 전환 |
| 유닛 (UnitTag) | Idle/AttackMove 상태에서만. 사용자 명령(Move, Build, Gather, Hold, Patrol, Attack) 우선 |

### 9. 게임오버 흐름

```
[Hero 사망 감지]
HeroDeathDetectionSystem (ServerDeathSystem 이전 실행)
    ↓
Health ≤ 0 + HeroTag 쿼리
    ↓
NetworkId → Connection 엔티티 매핑
    ↓
UserAliveState.IsAlive = false
    ↓
HeroDeathRpc 전송 (해당 유저 Connection)

[게임오버 체크]
모든 UserAliveState.IsAlive == false
    ↓
GameOverRpc 브로드캐스트 (모든 클라이언트)

[클라이언트 수신]
GameOverReceiveSystem
    ├─ HeroDeathRpc → UserContext.Dead + GameOverEvents.RaiseHeroDeath()
    └─ GameOverRpc → GameOverEvents.RaiseGameOver()
```

**핵심 포인트**:
- `UserAliveState`는 Connection 엔티티에 부착되어 Hero 파괴 후에도 상태 추적 가능
- `HeroDeathDetectionSystem`은 `ServerDeathSystem` 이전에 실행되어 Hero 파괴 전 상태 업데이트
- `_gameOverSent` 플래그로 GameOverRpc 중복 전송 방지
