# 엔티티 전투

# 전체 흐름

```
[Client] 우클릭 적 → AttackRequestRpc
    ↓
[Server] HandleAttackRequestSystem → Intent.Attack, AggroTarget 설정
    ↓
[SpatialPartitioningGroup]
SpatialMapBuildSystem → TargetingMap 빌드 (셀 크기: 10.0f)
    ↓
[SimulationSystemGroup]
UnifiedTargetingSystem → 적→아군, 유닛→적 자동 타겟팅 (SpatialMaps.TargetingMap 사용)
    ↓
[FixedStepSimulationSystemGroup]
┌──────────────┼──────────────┐
↓              ↓              ↓
MeleeAttack    RangedAttack   CombatDamage
(근접 공격)    (원거리 공격)   (투사체 충돌)
└──────────────┼──────────────┘
               ↓
        DamageEvent 버퍼 (Attacker 포함)
               ↓
        AggroReactionSystem → 피격 시 어그로 전환
               ↓
        DamageApplySystem → Health 적용 + 버퍼 클리어 + 적 킬 카운트 (GamePhaseState)
               ↓
[SimulationSystemGroup]
HeroDeathDetectionSystem → Hero 사망 감지, UserAliveState 업데이트, HeroDeathRpc/GameOverRpc 전송
               ↓
ServerDeathSystem → Health ≤ 0 삭제 + 인구수 반환
               ↓
[Client] GameOverReceiveSystem → RPC 수신 → UserContext.Dead 전환 + UI 이벤트 발생
```

## 컴포넌트 (Shared/Components/)

| 파일 | 역할 |
| --- | --- |
| CombatStats.cs | 공격력(AttackPower), 공격속도(AttackSpeed), 사거리(AttackRange) |
| Health.cs | 현재 체력(CurrentValue), 최대 체력(MaxValue) |
| Defense.cs  | 방어력 (0.0~1.0, 비율 감소) |
| AttackCooldown.cs | 다음 공격까지 남은 시간 (초). 서버 전용 (GhostField 없음) |
| AggroTarget.cs | 공격/추적 대상 엔티티 + 마지막 알려진 위치. 서버 전용 (GhostField 없음) |
| AggroLock.cs | 어그로 고정 (LockedTarget, RemainingLockTime, LockDuration). 서버 전용 (GhostField 없음) |
| ProjectileMove.cs | 투사체 방향, 속도, 남은 거리 |
| ObstacleRadius.cs | 엔티티 반지름 (거리 판정용) |
| UserAliveState.cs | 유저 생존 상태 (Connection 엔티티에 부착). IsAlive, HeroEntity 포함 |

## 버퍼 (Shared/Buffers/)

| 파일 | 역할 |
| --- | --- |
| DamageEvent.cs | 지연 데미지 기록. Damage + Attacker 포함. 여러 시스템이 Health 직접 수정 시 Job 충돌 방지용. AggroReactionSystem에서 Attacker 정보 읽은 후 DamageApplySystem에서 일괄 적용 |

## 태그 (Shared/Components/Tags/)

| 파일 | 역할 | 적용 대상 |
| --- | --- | --- |
| RangedUnitTag.cs | 원거리 유닛 표시 (MeleeAttackSystem 제외) | Archer, Tank |
| RangedEnemyTag.cs | 원거리 적 표시 (MeleeAttackSystem 제외) | EnemyFlying |
| VisualOnlyTag.cs | 시각 전용 투사체 (데미지 없음, CombatDamageSystem 제외) | 원거리 공격 시 생성 투사체 |

## 서버 시스템 (Server/Systems/)

### 타겟팅 시스템

파일: UnifiedTargetingSystem.cs
그룹: SimulationSystemGroup (UpdateAfter: SpatialPartitioningGroup, HandleAttackRequestSystem, UpdateBefore: PathfindingSystem)
역할: 통합 타겟팅 시스템. SpatialMaps.TargetingMap을 사용하여 공간 분할 기반 탐색.
- EnemyTargetJob: 적→아군 타겟팅 (유닛/건물 탐색, 타겟 없으면 랜덤 배회)
  - 셀 탐색 범위: `ceil(LoseTargetDistance / CellSize)` 동적 계산 (aggroRange가 CellSize보다 큰 경우 대응)
  - 시간 분할: 배회 중(타겟 없음)이면 4프레임에 1번만 탐색, 타겟 상실 시 즉시 탐색
- UnitAutoTargetJob: 유닛→적 자동 감지 (Idle/AttackMove/Attack 상태에서만, Worker 제외)
  - 시간 분할: 유효 타겟 보유 시 4프레임에 1번 "더 가까운 적" 재탐색, 타겟 무효/없음 시 즉시 탐색
  - 타겟 전환 조건: 새 타겟이 기존 타겟보다 가까운 경우에만 전환 (flickering 방지)
  - AggroLock 유효성 검증: 고정 타겟 사망/파괴 시 AggroLock 즉시 해제 → 정상 타겟팅 진행
  - 타겟 상실 처리: 타겟 사망 + 주변 적 없음 → Intent.Idle 전환 + MovementWaypoints 비활성화 (제자리 정지)
- EnemyWanderOnlyJob: SpatialMaps 없을 때 배회 전용 (아래 배회 시스템 참조)
- 최적화: 타겟 고착화(Hysteresis), 시간 분할(Time Slicing)
- **어그로 고정**: AggroLock.RemainingLockTime > 0이면 타겟 변경 불가
- **Partial Path 재시도**: `MovementMath.ShouldRetryPartialPath`로 판정. `MovementGoal.IsPathPartial`이면 2초(`MovementMath.PathRetryInterval`)마다 경로 재계산 (ElapsedTime 기반 + 프레임 분산). `MovementGoal.DestinationSetTime`으로 마지막 목적지 설정 시간 추적. Partial Path 상태에서 타겟 추적으로 목적지가 갱신되어도 DestinationSetTime을 리셋하지 않아 재시도 타이머 유지. IsPathPartial 판정은 PathfindingSystem에 위임.
- **건물 파괴 시 즉시 경로 갱신**: NavMeshObstacleCleanupSystem에서 파괴된 건물 12m 반경 내 Partial Path 엔티티의 IsPathDirty를 즉시 true로 설정. 2초 재시도 대기 없이 즉각 우회 경로 탐색.
- **배회 stuck 감지 → Dormant 전환**: `WanderUtility.CheckStuck`으로 판정. 3초(`WanderUtility.StuckCheckInterval`)마다 이동 거리 체크 (`MovementGoal.LastPositionCheck`, `LastPositionCheckTime`). 2m(`WanderUtility.StuckThreshold`) 미만 이동 시 stuck → `EnemyContext.Dormant` 전환 (이동/pathfinding 완전 중단, MovementWaypoints 비활성화, IsPathDirty=false). 5~8초 랜덤 타이머(`MovementGoal.DormantWakeTime`) 후 `Idle`로 깨어남. 피격(AggroLock 활성화) 시 즉시 깨어남. 벽 파괴 시 12m 내 Dormant 적 즉시 깨움(NavMeshObstacleCleanupSystem).

---

### 적 배회 시스템 (Enemy Wandering)

**상태**: `EnemyContext.Wandering` / `EnemyContext.Dormant` (EnemyState.cs)

**트리거 조건**:
- 타겟이 없을 때 (`AggroTarget.TargetEntity == Entity.Null`)
- 현재 상태가 `Wandering`이 아니거나 경로가 없을 때 (`!waypointsEnabled`)

**배회 목적지 결정** (WanderUtility.GenerateWanderDestination):
```csharp
// GridSettings 기반 맵 범위 내 랜덤 목적지 생성 (가장자리 5유닛 여유)
float3 wanderDest = WanderUtility.GenerateWanderDestination(
    entity.Index, FrameCount, ElapsedTime, myPos.y, in GridSettings);
```

**stuck 감지 → Dormant 전환** (WanderUtility.CheckStuck):
```csharp
// 3초간 2m 미만 이동 시 stuck → Dormant 전환
if (WanderUtility.CheckStuck(in myPos, goal.LastPositionCheck,
        goal.LastPositionCheckTime, ElapsedTime, out bool isStuck))
{
    if (isStuck)
    {
        enemyState.CurrentState = EnemyContext.Dormant;
        waypointsEnabled = false;       // 이동 중단
        goal.IsPathDirty = false;       // pathfinding 중단
        goal.DormantWakeTime = WanderUtility.CalculateDormantWakeTime(
            entity.Index, ElapsedTime); // 5~8초 랜덤
        return;
    }
    goal.LastPositionCheckTime = ElapsedTime;
    goal.LastPositionCheck = myPos;
}
```

**Dormant 깨어남 조건** (EnemyTargetJob/EnemyWanderOnlyJob Execute 최상단):
1. **피격**: `AggroLock.RemainingLockTime > 0` + `LockedTarget != Entity.Null` → 즉시 `Idle`
2. **타이머 만료**: `ElapsedTime >= goal.DormantWakeTime` → `Idle`
3. **벽 파괴**: `NavMeshObstacleCleanupSystem`에서 12m 내 Dormant 적 즉시 `Idle`

**실행 Job**:
| Job | 실행 조건 | 역할 |
|-----|----------|------|
| EnemyTargetJob | SpatialMaps 유효 | 타겟 탐색 실패 시 배회 로직 실행 |
| EnemyWanderOnlyJob | SpatialMaps 없음 | 배회 전용 (맵 빌드 전 fallback) |

**동작 흐름**:
1. 타겟 탐색 실패 → `EnemyContext.Wandering` 전환
2. `MovementGoal.Destination` = 랜덤 목적지
3. `MovementGoal.IsPathDirty` = true
4. `MovementGoal.DestinationSetTime` = ElapsedTime (Partial Path 재시도용)
5. `MovementGoal.LastPositionCheckTime` = ElapsedTime, `LastPositionCheck` = 현재 위치 (stuck 감지용)
6. `MovementWaypoints` 활성화 → PathfindingSystem에서 경로 계산
7. PathFollowSystem에서 이동 실행
8. 목적지 도착 또는 타겟 발견 시 다음 상태로 전환
9. 3초간 2m 미만 이동 시 stuck → Dormant 전환 (이동/pathfinding 완전 중단)
10. 5~8초 랜덤 타이머 후 Idle 복귀 → 재시도 (피격/벽 파괴 시 즉시 깨어남)

---

### 전투 시스템 (Server/Systems/Combat/)

파일: HandleAttackRequestSystem.cs
그룹: SimulationSystemGroup
역할: AttackRequestRpc 수신 → 소유권 검증 → UnitIntentState=Attack, AggroTarget 설정, MovementGoal 갱신 (추격 시작)
---
파일: MeleeAttackSystem.cs
그룹: FixedStepSimulationSystemGroup (UpdateAfter: PhysicsSystemGroup)
역할: 근접 공격 처리. 두 개 Job: EnemyMeleeAttackJob(적), UnitMeleeAttackJob(유닛).
- **거리 판정**: 직선거리 - 타겟 반지름(ObstacleRadius) = effectiveDist
- 사거리 내: DamageEvent 추가 (Attacker 포함) + 쿨다운 리셋 + 타겟 방향 회전
- 사거리 밖: 추격 (EnemyContext.Chasing / Action.Moving)
- RangedUnitTag/RangedEnemyTag 제외
- **MovementWaypoints 비활성화**: 공격 중 ECB로 비활성화 → PredictedMovementSystem에서 `IgnoreComponentEnabledState` + `EnabledRefRW`로 Separation 유지
---
파일: RangedAttackSystem.cs
그룹: FixedStepSimulationSystemGroup (UpdateAfter: MeleeAttackSystem)
역할: 원거리 공격 처리. IJobEntity + Burst + ECB.ParallelWriter로 병렬 처리.
- RangedUnitAttackJob: RangedUnitTag 유닛 처리 (Archer, Tank)
- RangedEnemyAttackJob: RangedEnemyTag 적 처리 (EnemyFlying)
- **거리 판정**: 직선거리 - 타겟 반지름(ObstacleRadius) = effectiveDist (근접과 동일, CombatUtility 사용)
- 필중 시스템: 유효 거리 판정 후 즉시 DamageEvent 추가 (ECB.AppendToBuffer, Attacker 포함) + 시각 투사체 생성(CombatUtility.SpawnVisualProjectile, VisualOnlyTag)
- 사거리 내: 이동 비활성화, 타겟 방향 회전 (CombatUtility.RotateTowardTarget)
- 사거리 밖: 추격 (MovementGoal 업데이트)
---
파일: CombatDamageSystem.cs
그룹: PhysicsSystemGroup (UpdateAfter: PhysicsSimulationGroup)
역할: Physics Trigger 기반 투사체 충돌 처리.
- ITriggerEventsJob으로 충돌 감지
- VisualOnlyTag 제외 (시각 투사체는 데미지 없음)
- 충돌 시 DamageEvent 추가 (Attacker=투사체) + 투사체 삭제
- NativeParallelHashSet으로 프레임당 중복 히트 방지
- 아군 히트 방지 (같은 Team은 무시)
---
파일: AggroReactionSystem.cs
그룹: FixedStepSimulationSystemGroup (UpdateAfter: RangedAttackSystem, UpdateBefore: DamageApplySystem)
역할: **피격 시 어그로 반응 시스템 (신규)**
- DamageEvent 버퍼에서 Attacker 정보를 읽어 어그로 전환
- AggroLock.LockDuration 동안 어그로 고정 (RemainingLockTime)
- EnemyAggroReactionJob: 적 어그로 반응 (항상 활성화)
- UnitAggroReactionJob: 유닛 어그로 반응 (사용자 명령 우선)
  - Move, Build, Gather, Hold, Patrol, Attack 상태면 무시
  - Idle/AttackMove 상태에서만 피격 어그로 활성화
  - 어그로 전환 시 Intent.Attack으로 변경
---
파일: DamageApplySystem.cs
그룹: FixedStepSimulationSystemGroup (UpdateAfter: MeleeAttackSystem)
역할: DamageEvent 버퍼 합산 → Health에 적용 → 버퍼 클리어 + 적 킬 카운트.
- **AggroReactionSystem 이후 실행**: Attacker 정보는 이미 처리됨
- 핵심: 모든 데미지 시스템의 결과를 일괄 처리
- **킬 카운트 통합**: 이번 프레임에 사망한 EnemyTag 엔티티를 카운트하여 GamePhaseState.TotalKillCount 갱신 (기존 EnemyDeathCountSystem 통합)
---
파일: HeroDeathDetectionSystem.cs
그룹: SimulationSystemGroup (UpdateBefore: ServerDeathSystem)
역할: Hero 사망 감지 및 게임오버 처리 (ServerDeathSystem에서 Hero 파괴 전 실행)
- Health ≤ 0 + HeroTag인 엔티티 감지
- Connection 엔티티의 UserAliveState.IsAlive = false 설정
- HeroDeathRpc 전송 (해당 유저에게)
- 모든 유저 사망 시 GameOverRpc 브로드캐스트
---
파일: ServerDeathSystem.cs
그룹: SimulationSystemGroup
역할: Health ≤ 0인 엔티티 삭제 (ECB.DestroyEntity) + 인구수 반환 (PopulationEvent)

## 클라이언트 시스템 (Client/Systems/)

파일: ClientDeathSystem.cs
위치: Client/Systems/Combat/
그룹: SimulationSystemGroup
역할: Health ≤ 0인 엔티티에 DisableRendering 추가. 서버 삭제 전까지 렌더링만 끔 (갑작스러운 사라짐 방지)
---
파일: ProjectileVisualSystem.cs
위치: Client/Systems/Combat/
그룹: SimulationSystemGroup
역할: 시각 투사체(VisualOnlyTag) 이동. RemainingDistance 감소 → 0 이하면 삭제. (RPC 미사용, Ghost 복제로 동기화)
---
파일: GameOverReceiveSystem.cs
위치: Client/Systems/
그룹: SimulationSystemGroup
역할: 게임오버 관련 RPC 수신 처리
- HeroDeathRpc 수신 → UserState.CurrentState = UserContext.Dead + GameOverEvents.RaiseHeroDeath()
- GameOverRpc 수신 → GameOverEvents.RaiseGameOver()

## 공간 분할 시스템 (Server/Systems/Spatial/)

파일: SpatialMapBuildSystem.cs
그룹: SpatialPartitioningGroup (OrderFirst=true)
역할: 공간 분할 맵 빌드
- TargetingMap (셀 크기: 10.0f): 타겟팅용 공간 해시맵
- MovementMap (셀 크기: 3.0f): 이동 충돌 회피용 (대형 유닛 AABB 등록)
- Persistent 맵을 매 프레임 Job 기반 Clear 후 재빌드 (CompleteDependency 불필요)
- 결과를 SpatialMaps 싱글톤에 저장

## Shared 시스템 (Shared/Systems/)

파일: ProjectileMoveSystem.cs
그룹: SimulationSystemGroup
역할: 투사체 이동 (서버/클라이언트 공용). Direction * Speed * dt 이동, RemainingDistance 감소

## 유틸리티 (Shared/Utilities/)

| 파일 | 역할 |
| --- | --- |
| CombatUtility.cs | 전투 공통 유틸리티. CalculateEffectiveDistance(유효 거리), GetEffectiveDistance(ObstacleRadius Lookup 포함 유효 거리), IsTargetAlive(타겟 생존 확인: Transform+Health+HP>0), ApplyDamage(Defense 조회+데미지 계산+DamageEvent 추가), TickCooldown(쿨다운 감소), RotateTowardTarget(타겟 회전), ResetCooldown(쿨다운 리셋), SpawnVisualProjectile(시각 투사체 생성) |
| DamageUtility.cs | 데미지 계산: finalDamage = baseDamage * (1 - defense). Defense 0.3이면 30% 감소 |
| WanderUtility.cs | 적 배회 유틸리티. CheckStuck(stuck 감지), GenerateWanderDestination(랜덤 배회 목적지 생성), CalculateDormantWakeTime(Dormant 깨어남 시간 계산, 5~8초 랜덤) |
| MovementMath.cs | 이동 계산 유틸리티. ShouldRetryPartialPath(Partial Path 재시도 판정) 포함 |

## RPC (Shared/RPCs/)

| 파일 | 역할 |
| --- | --- |
| AttackRequestRpc.cs | 공격 명령 RPC. UnitGhostId, TargetGhostId, TargetPosition 포함 |
| HeroDeathRpc.cs | 서버 → 클라이언트: 해당 유저의 Hero 사망 알림 |
| GameOverRpc.cs | 서버 → 클라이언트: 게임오버 브로드캐스트 (모든 Hero 사망 시) |

## 핵심 설계 포인트

### 1. DamageEvent 버퍼 패턴

DamageEvent 버퍼에 기록 (Attacker 포함) → AggroReactionSystem에서 어그로 처리 → DamageApplySystem에서 일괄 적용 + 버퍼 클리어

```csharp
// 공격 시스템에서 DamageEvent 추가
ECB.AppendToBuffer(sortKey, targetEntity, new DamageEvent
{
    Damage = finalDamage,
    Attacker = attackerEntity  // 어그로 전환용
});
```

### 2. 어그로 고정 패턴 (AggroLock)

피격 시 N초 동안 어그로 대상 변경 불가. UnifiedTargetingSystem에서 체크.

```csharp
// AggroReactionSystem에서 어그로 고정
if (canSwitchTarget)
{
    aggroTarget.TargetEntity = validAttacker;
    aggroLock.LockedTarget = validAttacker;
    aggroLock.RemainingLockTime = aggroLock.LockDuration;  // 고정 시작
}

// UnifiedTargetingSystem에서 고정 체크 (EnemyTargetJob / UnitAutoTargetJob 공통 패턴)
if (aggroLock.RemainingLockTime > 0f && aggroLock.LockedTarget != Entity.Null)
{
    Entity lockedTarget = aggroLock.LockedTarget;

    // 고정 타겟 유효성 검증: Transform + Health + HP > 0
    if (TransformLookup.TryGetComponent(lockedTarget, out var t) &&
        HealthLookup.TryGetComponent(lockedTarget, out var h) && h.CurrentValue > 0)
    {
        return; // 유효한 고정 타겟 → 탐색 스킵
    }
    // 고정 타겟 사망/파괴 → AggroLock 해제, 정상 타겟팅 진행
    aggroLock.RemainingLockTime = 0f;
    aggroLock.LockedTarget = Entity.Null;
}
```

### 3. 공격 타입별 처리

| 타입 | 시스템 | 필터 | 데미지 방식 |
| --- | --- | --- | --- |
| 근접 | MeleeAttackSystem | WithNone<RangedUnitTag/RangedEnemyTag> | (직선거리 - 타겟 반지름) ≤ 사거리 → DamageEvent |
| 원거리 | RangedAttackSystem | WithAll<RangedUnitTag/RangedEnemyTag> | (직선거리 - 타겟 반지름) ≤ 사거리 → 즉시 DamageEvent (필중) + 시각 투사체 |
| 투사체 | CombatDamageSystem | Physics Trigger | 충돌 시 DamageEvent |

### 4. 거리 판정 (RTS 스타일)

근접/원거리 모두 동일한 유효 거리 계산 적용 (CombatUtility 공통 사용):
```csharp
// ObstacleRadius Lookup 포함 유효 거리 계산 → CombatUtility.GetEffectiveDistance
float effectiveDist = CombatUtility.GetEffectiveDistance(myPos, targetPos, targetEntity, in ObstacleRadiusLookup);
bool isInRange = effectiveDist <= combatStats.AttackRange;
```

### 5. 시각 투사체 (원거리 공격)

서버: RangedAttackSystem
→ 데미지 즉시 적용 (필중)
→ 투사체 엔티티 생성 + VisualOnlyTag + ProjectileMove
→ Ghost로 클라이언트 복제

클라이언트: ProjectileVisualSystem
→ 복제된 투사체 이동 표시
→ RemainingDistance ≤ 0 삭제

### 6. 시스템 실행 순서

```
[SpatialPartitioningGroup] ─────────────────────────────
SpatialMapBuildSystem (OrderFirst)
    → TargetingMap 빌드 (셀 크기: 10.0f)
    → MovementMap 빌드 (셀 크기: 3.0f)
    → SpatialMaps 싱글톤에 저장

[SimulationSystemGroup] ─────────────────────────────────
HandleAttackRequestSystem
    ↓ UpdateAfter
UnifiedTargetingSystem (SpatialMaps.TargetingMap 사용)
    ├─ EnemyTargetJob (적→아군 타겟팅, AggroLock 체크)
    ├─ UnitAutoTargetJob (유닛→적 자동 감지, AggroLock 체크)
    └─ EnemyWanderOnlyJob (타겟 없을 때 배회)

[PhysicsSystemGroup] ────────────────────────────────────
PhysicsSimulationGroup
    ↓ UpdateAfter
CombatDamageSystem (투사체 충돌, VisualOnlyTag 제외)

[FixedStepSimulationSystemGroup] ────────────────────────
    ↓ UpdateAfter: PhysicsSystemGroup
MeleeAttackSystem (근접, RangedUnitTag/RangedEnemyTag 제외)
    ↓ UpdateAfter
RangedAttackSystem (원거리, RangedUnitTag/RangedEnemyTag 대상)
    ↓ UpdateAfter
AggroReactionSystem (피격 어그로 반응, DamageEvent.Attacker 읽기)
    ↓ UpdateAfter: MeleeAttackSystem
DamageApplySystem (데미지 적용 + 버퍼 클리어 + 적 킬 카운트)

[SimulationSystemGroup] ─────────────────────────────────
HeroDeathDetectionSystem (UpdateBefore: ServerDeathSystem)
    → Hero 사망 감지 (Health ≤ 0 + HeroTag)
    → UserAliveState.IsAlive = false
    → HeroDeathRpc 전송 (해당 유저)
    → 모든 유저 사망 시 GameOverRpc 브로드캐스트
    ↓
ServerDeathSystem → Health ≤ 0 삭제 + 인구수 반환

[SimulationSystemGroup - Client] ────────────────────────
GameOverReceiveSystem
    → HeroDeathRpc 수신 → UserContext.Dead + GameOverEvents.RaiseHeroDeath()
    → GameOverRpc 수신 → GameOverEvents.RaiseGameOver()

```

### 7. 공간 분할 최적화 기법

| 기법 | 설명 |
| --- | --- |
| 타겟 고착화 (Hysteresis) | LoseTargetDistance = DetectionRange × 1.3배 |
| 시간 분할 - EnemyTargetJob | 배회 중(hadTarget=false): 4프레임 분할. 타겟 상실(hadTarget=true): 즉시 탐색 |
| 시간 분할 - UnitAutoTargetJob | 유효 타겟 보유: 4프레임에 1번 더 가까운 적 재탐색. 타겟 무효/없음: 즉시 탐색 |
| 동적 셀 탐색 범위 | `ceil(range / CellSize)` → aggroRange > CellSize인 경우 셀 경계 누락 방지 |
| 타겟 전환 방지 | UnitAutoTargetJob: 새 타겟이 기존보다 가까운 경우에만 전환 (shouldSwitch) |
| 대형 유닛 AABB | radius > CellSize × 0.5f인 경우 여러 셀에 등록 |
| 해시 충돌 방지 | capacity = entityCount × 1.5f |

### 8. 어그로 반응 조건 (유닛 vs 적)

| 유닛 종류 | 어그로 반응 조건 |
| --- | --- |
| 적 (EnemyTag) | 항상 활성화. 피격 시 공격자에게 어그로 전환 |
| 유닛 (UnitTag) | Idle/AttackMove 상태에서만. 사용자 명령(Move, Build, Gather, Hold, Patrol, Attack) 우선 |

### 9. 게임오버 흐름

```
[Hero 사망 감지]
HeroDeathDetectionSystem (ServerDeathSystem 이전 실행)
    ↓
Health ≤ 0 + HeroTag 쿼리
    ↓
NetworkId → Connection 엔티티 매핑
    ↓
UserAliveState.IsAlive = false
    ↓
HeroDeathRpc 전송 (해당 유저 Connection)

[게임오버 체크]
모든 UserAliveState.IsAlive == false
    ↓
GameOverRpc 브로드캐스트 (모든 클라이언트)

[클라이언트 수신]
GameOverReceiveSystem
    ├─ HeroDeathRpc → UserContext.Dead + GameOverEvents.RaiseHeroDeath()
    └─ GameOverRpc → GameOverEvents.RaiseGameOver()
```

**핵심 포인트**:
- `UserAliveState`는 Connection 엔티티에 부착되어 Hero 파괴 후에도 상태 추적 가능
- `HeroDeathDetectionSystem`은 `ServerDeathSystem` 이전에 실행되어 Hero 파괴 전 상태 업데이트
- `_gameOverSent` 플래그로 GameOverRpc 중복 전송 방지
