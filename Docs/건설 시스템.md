# 건설 시스템

## 전체 흐름

```
[Client] Q키 → BuildMenu 진입 → 건물 선택 → Construction 모드
       ↓
마우스 Raycast → GridPosition 계산 → StructurePreviewUpdateSystem (검증)
       ↓
좌클릭 시 분기:
├─ [사거리 내] BuildRequestRpc → HandleBuildRequestSystem → 즉시 건물 생성
└─ [사거리 밖] BuildMoveRequestRpc → HandleBuildMoveRequestSystem
                                    → MovementGoal + PendingBuildServerData 설정
       ↓
PathfindingSystem → PredictedMovementSystem
       ↓
MovementArrivalSystem → BuildArrivalSystem → 도착 시 건물 생성
```

## 핵심 설계 포인트

1. **2경로 건설**: 사거리 내 즉시 건설(BuildRequestRpc) vs 사거리 밖 이동 후 건설(BuildMoveRequestRpc)
2. **병렬+직렬 Job 패턴**: 물리/그리드 검증은 병렬, 자원 차감/엔티티 생성은 직렬
3. **PendingBuildServerData**: 이동 중 건설 예약 정보를 유닛에 저장, 도착 시 BuildArrivalSystem이 처리
4. **GhostId 기반 건설자 제외**: 충돌 검사 시 건설자 유닛을 제외하여 자기 충돌 방지
5. **클라이언트 비용 검증**: 자원 부족 시 Invalid 상태로 표시 (서버 검증 전 사전 차단)

---

## 클라이언트 시스템 (Client/Systems/)

| 파일 | 그룹 | 역할 |
| --- | --- | --- |
| ConstructionMenuInputSystem.cs | GhostInputSystemGroup | Q키 → BuildMenu 진입, Q/W/E/R 키로 건물 선택 → Construction 모드, BuildSelectionUtility 사용 |
| StructurePreviewUpdateSystem.cs | PresentationSystemGroup | 마우스 위치 → 그리드 점유/물리 충돌/자원 노드 구역/비용 검증, 사거리 계산 → PlacementStatus 결정 (Invalid/ValidInRange/ValidOutOfRange) |
| StructurePlacementInputSystem.cs | GhostInputSystemGroup (UpdateAfter: UnitCommandInputSystem) | 좌클릭 시 PlacementStatus에 따라 BuildRequestRpc 또는 BuildMoveRequestRpc 전송 |

---

## 서버 시스템 (Server/Systems/)

| 파일 | 그룹 | 역할 |
| --- | --- | --- |
| HandleBuildRequestSystem.cs | SimulationSystemGroup | BuildRequestRpc 수신 → 2-Job 구조 (Job1: 물리/그리드 검증 병렬, Job2: 자원 차감+건물 생성 직렬). 건설자 GhostId 기반 충돌 제외, ResourceCenter 건설 시 UserTechState 업데이트 |
| HandleBuildMoveRequestSystem.cs | SimulationSystemGroup | BuildMoveRequestRpc 수신 → GhostId→Entity 변환, 소유권 검증, MovementGoal 설정, UnitIntentState=Build, PendingBuildServerData 추가 |
| BuildArrivalSystem.cs | SimulationSystemGroup (UpdateAfter: MovementArrivalSystem) | PendingBuildServerData 보유 유닛의 MovementWaypoints 비활성화 감지 → 거리 검증 → 자원 확인/차감 → 건물 생성 → PendingBuildServerData 제거, Intent=Idle |

---

## Authoring (Authoring/)

| 파일 | 베이킹 컴포넌트 |
| --- | --- |
| StructureAuthoring.cs | StructureTag, Team, Health, GridPosition, StructureFootprint, ObstacleRadius, WallTag/ProductionFacilityTag/ResourceCenterTag 등 |
| UnitMovementAuthoring.cs | UnitIntentState (Intent.Build 상태 포함), UnitActionState, UnitCommand 버퍼 |

---

## 유틸리티 (Client/Utilities/)

| 파일 | 역할 |
| --- | --- |
| BuildSelectionUtility.cs | 건설 명령 공통 로직. TrySelectStructure(): AvailableStructure 버퍼 조회, 테크 트리 해금 확인, 글로벌 인덱스 맵 변환 |

---

## 컴포넌트 (Shared/Components/)

| 파일 | 역할 |
| --- | --- |
| State/ConstructionState.cs | 건물 건설 진행 상태 (Progress, TotalBuildTime) |
| Stats/StructureFootprint.cs | 건물 그리드 크기 (Width, Length, Height), 사거리 계산에 사용 |
| Stats/WorkRange.cs | 빌더 유닛 작업 사거리, 사거리 내/밖 판정 기준 |
| State/UnitIntentState.cs | 유닛 의도 상태 (Intent.Build = 이동 중 건설 예약) |
| Data/UserTechState.cs | 유저 기술 해금 상태 (HasResourceCenter) |

---

## 서버 데이터 (Server/Data/)

| 파일 | 역할 |
| --- | --- |
| PendingBuildServerData.cs | 이동 후 건설용 대기 데이터. StructureIndex, GridPosition, BuildSiteCenter, StructureRadius, OwnerNetworkId, SourceConnection 저장 |
| BuildActionRequest.cs | HandleBuildRequestSystem 내부용. Job1→Job2 데이터 전달 큐 (검증 결과 + 계산된 좌표) |

---

## 싱글톤 (Client/Component/Singleton/)

| 파일 | 역할 |
| --- | --- |
| UserState.cs | 유저 컨텍스트 상태머신 (Command/BuildMenu/Construction). Q키로 전환 |
| StructurePreviewState.cs | 건설 프리뷰 상태. SelectedPrefab, SelectedPrefabIndex, GridPosition, IsValidPlacement, Status (PlacementStatus), DistanceToBuilder |

---

## 프리뷰 렌더링 (Client/Controller/)

| 파일 | 역할 |
| --- | --- |
| StructurePreviewController.cs | MonoBehaviour. StructurePreviewState 싱글톤을 읽어 건물 프리뷰 + 양탄자(격자 영역) 렌더링 |

### StructurePreviewController 구조

```
건물 프리뷰 (원래 프리팹)     양탄자 (Quad)
┌─────────────────┐         ┌─────────────────┐
│  원래 크기/머티리얼  │         │  그리드 크기 스케일  │
│  Height/2 + 0.05f  │         │    Y = 0.05f      │
└─────────────────┘         └─────────────────┘
       ↑                            ↑
  _currentPreview              _carpetObject (별도 오브젝트)
```

**설계 포인트:**
1. **건물 프리뷰**: 프리팹 원본 크기/머티리얼 유지 (스케일링 없음)
2. **양탄자**: `PrimitiveType.Quad`로 생성, 그리드 크기(Width × Length × CellSize)로 스케일
3. **별도 오브젝트 관리**: 프리팹 스케일 영향 방지를 위해 양탄자를 자식이 아닌 별도 오브젝트로 관리
4. **상태별 색상**: 양탄자 머티리얼만 PlacementStatus에 따라 변경
   - `ValidInRange` → 파란색 (`GridCarpetBlue.mat`)
   - `ValidOutOfRange` → 노란색 (`GridCarpetYellow.mat`)
   - `Invalid` → 빨간색 (`GridCarpetRed.mat`)

**머티리얼 경로:** `Assets/Materials/Preview/GridCarpet*.mat`

---

## RPC (Shared/RPCs/)

| 파일 | 역할 |
| --- | --- |
| BuildRequestRpc.cs | 사거리 내 즉시 건설 요청. StructureIndex, GridPosition, BuilderGhostId |
| BuildMoveRequestRpc.cs | 사거리 밖 이동 후 건설 요청. StructureIndex, GridPosition, MoveTarget, BuildSiteCenter, StructureRadius, BuilderGhostId |
| NotificationRpc.cs | 서버→클라이언트 알림 (InsufficientFunds 등) |

---

## 상태 흐름

### UserState 전환

```
Command ─[Q키+빌더 선택]→ BuildMenu ─[Q/W/E/R]→ Construction ─[좌클릭/ESC]→ Command
```

### PlacementStatus 결정

```
StructurePreviewUpdateSystem (PresentationSystemGroup):
├─ 그리드 점유? → Invalid
├─ 물리 충돌? (건설자 제외) → Invalid
├─ 자원 노드 제외 구역? (ResourceCenter만) → Invalid
├─ 자원 부족? (UserCurrency < Cost) → Invalid
└─ 사거리 계산:
   ├─ distanceToSurface ≤ WorkRange → ValidInRange (초록)
   └─ distanceToSurface > WorkRange → ValidOutOfRange (노랑)
```

### UnitIntentState 변화 (이동 후 건설)

```
HandleBuildMoveRequestSystem: Intent.Build 설정
       ↓ (이동 중)
BuildArrivalSystem: Intent.Idle 복귀
```

---

## 시스템 실행 순서

```
[GhostInputSystemGroup - Client]
ConstructionMenuInputSystem → Q키 메뉴 처리
UnitCommandInputSystem → 우클릭 명령
    ↓ UpdateAfter
StructurePlacementInputSystem → 좌클릭 시 RPC 전송

[PresentationSystemGroup - Client]
StructurePreviewUpdateSystem → 그리드/물리/비용 검증, PlacementStatus 결정

[SimulationSystemGroup - Server]
HandleBuildRequestSystem → 즉시 건설 (2-Job 구조)
HandleBuildMoveRequestSystem → 이동 후 건설 설정
    ↓ UpdateAfter: MovementArrivalSystem
BuildArrivalSystem → 도착 시 건물 생성
```

---

## 건설자 충돌 제외 로직

### 클라이언트 (StructurePreviewUpdateSystem)

```csharp
// builderEntity를 직접 비교하여 제외
if (builderEntity != Entity.Null && hitEntity == builderEntity)
{
    continue; // 건설자는 충돌에서 제외
}
```

### 서버 (HandleBuildRequestSystem)

```csharp
// GhostId 기반 계층 탐색 (Parent 추적)
private bool IsBuilder(Entity hitEntity, int builderGhostId)
{
    Entity current = hitEntity;
    for (int i = 0; i < 3; i++)  // 최대 3단계 Parent 탐색
    {
        if (GhostInstanceLookup.HasComponent(current))
            return GhostInstanceLookup[current].ghostId == builderGhostId;
        if (ParentLookup.HasComponent(current))
            current = ParentLookup[current].Value;
        else break;
    }
    return false;
}
```

---

## 테크 상태 업데이트

ResourceCenter 건설 시 `UserTechState.HasResourceCenter = true` 설정:

```csharp
// HandleBuildRequestSystem.ExecuteBuildRequestJob
if (ResourceCenterTagLookup.HasComponent(request.PrefabEntity))
{
    UpdateTechState(request.SourceNetworkId, hasResourceCenter: true);
}

// BuildArrivalSystem.TryBuild
if (_resourceCenterTagLookup.HasComponent(structurePrefab))
{
    techState.HasResourceCenter = true;
    _userTechStateLookup[userCurrencyEntity] = techState;
}
```
