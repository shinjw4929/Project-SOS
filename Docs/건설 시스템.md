# 건설 시스템

## 전체 흐름

```
[Client] Q키 → BuildMenu 진입 → Q/W/E/R 건물 선택 → Construction 모드
       ↓
마우스 Raycast → GridPosition 계산 → StructurePreviewUpdateSystem (검증)
       ↓
좌클릭 시 분기:
├─ [사거리 내] BuildRequestRpc → HandleBuildRequestSystem → 즉시 건물 생성
└─ [사거리 밖] BuildMoveRequestRpc → HandleBuildMoveRequestSystem
                                    → MovementGoal + PendingBuildServerData 설정
       ↓
PathfindingSystem → PredictedMovementSystem
       ↓
MovementArrivalSystem → BuildArrivalSystem → 도착 시 건물 생성
```

## 핵심 설계 포인트

1. **2경로 건설**: 사거리 내 즉시 건설(BuildRequestRpc) vs 사거리 밖 이동 후 건설(BuildMoveRequestRpc)
2. **병렬+직렬 Job 패턴**: 물리/그리드 검증은 병렬(ValidateBuildRequestJob), 자원 차감/엔티티 생성은 직렬(ExecuteBuildRequestJob)
3. **PendingBuildServerData**: 이동 중 건설 예약 정보를 유닛에 저장, 도착 시 BuildArrivalSystem이 처리
4. **GhostId 기반 건설자 제외**: 충돌 검사 시 건설자 유닛을 제외하여 자기 충돌 방지 (Parent 계층 탐색)
5. **클라이언트 비용 검증**: 자원 부족 시 Invalid 상태로 표시 (서버 검증 전 사전 차단)
6. **좌표 사전 계산**: ValidateBuildRequestJob에서 월드 좌표를 미리 계산하여 ExecuteBuildRequestJob에 전달 (TargetWorldPos)

---

## 클라이언트 시스템 (Client/Systems/Commands/Construction/)

| 파일 | 그룹 | 역할 |
| --- | --- | --- |
| ConstructionMenuInputSystem.cs | GhostInputSystemGroup | Q키 → BuildMenu 진입 (BuilderTag+AvailableStructure 버퍼 확인), Q/W/E/R 키로 건물 선택 → Construction 모드, ESC로 취소, BuildSelectionUtility 사용 |
| StructurePreviewUpdateSystem.cs | PresentationSystemGroup | 그리드 점유 → 자원 노드 구역(ResourceCenter만) → 물리 충돌(건설자 제외) → 사거리 계산 → 비용 검증 순서로 PlacementStatus 결정 |
| StructurePlacementInputSystem.cs | GhostInputSystemGroup (UpdateAfter: UnitCommandInputSystem) | 좌클릭 시 PlacementStatus에 따라 BuildRequestRpc 또는 BuildMoveRequestRpc 전송, 이동 목표 좌표(MoveTarget) 계산 포함 |

---

## 서버 시스템 (Server/Systems/Commands/Construction/)

| 파일 | 그룹 | 역할 |
| --- | --- | --- |
| HandleBuildRequestSystem.cs | SimulationSystemGroup | BuildRequestRpc 수신 → 2-Job 구조. ValidateBuildRequestJob(병렬): 물리/그리드/자원노드 구역 검증 + 월드좌표 사전계산. ExecuteBuildRequestJob(직렬): 자원 차감 + 건물 생성. ResourceCenter 건설 시 UserTechState 업데이트 |
| HandleBuildMoveRequestSystem.cs | SimulationSystemGroup (UpdateAfter: UnifiedTargetingSystem) | BuildMoveRequestRpc 수신 → GhostIdMap으로 Entity 변환, 소유권 검증, MovementGoal 설정(건물 가장자리=빌더 방향 StructureRadius 지점), UnitIntentState=Build, AggroTarget 초기화, PendingBuildServerData 추가, MovementWaypoints 활성화, ArrivalRadius=unitRadius+0.5f |
| BuildArrivalSystem.cs | SimulationSystemGroup (UpdateAfter: MovementArrivalSystem) | PendingBuildServerData 보유 유닛 + MovementWaypoints 비활성화 감지 → 거리 검증(arrivalThreshold = WorkRange) → 자원 확인/차감 → 건물 생성 → PendingBuildServerData 제거, Intent=Idle |

---

## Authoring (Authoring/)

| 파일 | 베이킹 컴포넌트 |
| --- | --- |
| StructureAuthoring.cs | StructureTag, Team, Health, GridPosition, StructureFootprint, ObstacleRadius, WallTag/ProductionFacilityTag/ResourceCenterTag 등 |
| UnitMovementAuthoring.cs | UnitIntentState (Intent.Build 상태 포함), UnitActionState, UnitCommand 버퍼 |

---

## 유틸리티

### Client/Utilities/

| 파일 | 역할 |
| --- | --- |
| BuildSelectionUtility.cs | 건설 명령 공통 로직. TrySelectStructure(): AvailableStructure 버퍼 조회, 테크 트리 해금 확인, 글로벌 인덱스 맵 변환 |

### Shared/Utilities/

| 파일 | 역할 |
| --- | --- |
| BuildingUtility.cs | 건물 엔티티 생성 공통 로직. CreateBuilding(): Instantiate → Transform(Scale/Rotation 유지) → GridPosition → GhostOwner/Team → UnderConstructionTag → NeedsNavMeshObstacle. HandleBuildRequestSystem, BuildArrivalSystem에서 공유 |
| EconomyUtility.cs | 알림 RPC 전송 공통 로직. SendNotification(): Entity.Null 체크 → NotificationRpc + SendRpcCommandRequest 생성. HandleBuildRequestSystem, BuildArrivalSystem, HandleProduceUnitRequestSystem에서 공유 |

---

## 컴포넌트 (Shared/Components/)

| 파일 | 역할 |
| --- | --- |
| State/ConstructionState.cs | 건물 건설 진행 상태 (Progress, TotalBuildTime) |
| Stats/StructureFootprint.cs | 건물 그리드 크기 (Width, Length, Height), 사거리 계산에 사용 |
| Stats/WorkRange.cs | 빌더 유닛 작업 사거리, 사거리 내/밖 판정 기준 |
| State/UnitIntentState.cs | 유닛 의도 상태 (Intent.Build = 이동 중 건설 예약) |
| Data/UserTechState.cs | 유저 기술 해금 상태 (HasResourceCenter) |

---

## 서버 데이터 (Server/Data/)

| 파일 | 역할 |
| --- | --- |
| PendingBuildServerData.cs | 이동 후 건설용 대기 데이터: `StructureIndex`, `GridPosition`, `BuildSiteCenter`, `StructureRadius`, `OwnerNetworkId`, `SourceConnection` |
| BuildActionRequest.cs | HandleBuildRequestSystem 내부용 Job1→Job2 데이터 전달: `RpcEntity`, `PrefabEntity`, `SourceNetworkId`, `SourceConnection`, `GridPosition`, `TargetWorldPos`(사전계산된 월드좌표), `StructureCost`, `IsValidPhysics` |

---

## 싱글톤 (Client/Component/)

| 파일 | 역할 |
| --- | --- |
| Singleton/UserState.cs | 유저 컨텍스트 상태머신 (Command/BuildMenu/Construction). Q키로 전환, ESC로 취소 |
| Structures/StructurePreviewState.cs | 건설 프리뷰 상태: `SelectedPrefab`(원본 프리팹), `SelectedPrefabIndex`(서버 전송용), `GridPosition`, `IsValidPlacement`(하위 호환), `Status`(PlacementStatus), `DistanceToBuilder` |

### PlacementStatus 열거형

```csharp
public enum PlacementStatus : byte
{
    Invalid = 0,        // 건설 불가 (빨간색)
    ValidInRange = 1,   // 건설 가능 + 사거리 내 (파란색)
    ValidOutOfRange = 2 // 건설 가능 + 사거리 밖 (노란색)
}
```

---

## 프리뷰 렌더링 (Client/Controller/)

| 파일 | 역할 |
| --- | --- |
| StructurePreviewController.cs | MonoBehaviour. StructurePreviewState 싱글톤을 읽어 건물 프리뷰 + 양탄자(격자 영역) 렌더링 |

### StructurePreviewController 구조

```
건물 프리뷰 (원래 프리팹)     양탄자 (Quad)
┌─────────────────┐         ┌─────────────────┐
│  원래 크기/머티리얼  │         │  그리드 크기 스케일  │
│  Height/2 + 0.05f  │         │    Y = 0.05f      │
└─────────────────┘         └─────────────────┘
       ↑                            ↑
  _currentPreview              _carpetObject (별도 오브젝트)
```

**설계 포인트:**
1. **건물 프리뷰**: StructurePrefabStore에서 프리팹 조회, 원본 크기/머티리얼 유지
2. **양탄자**: `PrimitiveType.Quad`로 생성, 그리드 크기(Width × Length × CellSize)로 스케일, XZ평면에 눕힘
3. **Dirty Flag 패턴**: `_cachedPrefabIndex`로 인덱스 변경 시에만 프리뷰 재생성 (최적화)
4. **별도 오브젝트 관리**: 프리팹 스케일 영향 방지를 위해 양탄자를 자식이 아닌 별도 오브젝트로 관리
5. **상태별 색상**: 양탄자 머티리얼만 PlacementStatus에 따라 변경 (switch expression 사용)
   - `ValidInRange` → `carpetValidMaterial` (파란색)
   - `ValidOutOfRange` → `carpetOutOfRangeMaterial` (노란색)
   - `Invalid` → `carpetInvalidMaterial` (빨간색)

**Inspector 설정 필드:**
- `carpetValidMaterial`: 사거리 내 건설 가능 (파란색)
- `carpetInvalidMaterial`: 건설 불가 (빨간색)
- `carpetOutOfRangeMaterial`: 사거리 밖 이동 후 건설 (노란색)

---

## RPC (Shared/RPCs/)

| 파일 | 역할 |
| --- | --- |
| BuildRequestRpc.cs | 사거리 내 즉시 건설 요청: `StructureIndex`, `GridPosition`, `BuilderGhostId`(충돌 검사 제외용) |
| BuildMoveRequestRpc.cs | 사거리 밖 이동 후 건설 요청: `BuilderGhostId`, `StructureIndex`, `GridPosition`, `MoveTarget`(이동 목표), `BuildSiteCenter`(건물 중심), `StructureRadius`(도착 판정용) |
| NotificationRpc.cs | 서버→클라이언트 알림 (InsufficientFunds 등) |

---

## 상태 흐름

### UserState 전환

```
Command ─[Q키+빌더 선택]→ BuildMenu ─[Q/W/E/R]→ Construction ─[좌클릭/ESC]→ Command
```

### PlacementStatus 결정 (StructurePreviewUpdateSystem)

```
1. 기본 조건 체크
   └─ CurrentState != Construction || SelectedPrefab == Null → Invalid

2. 프리팹 데이터 확인
   └─ StructureFootprint 없음 → Invalid

3. 그리드 점유 확인
   └─ GridUtility.IsOccupied() = true → isOccupied = true

4. 자원 노드 제외 구역 (ResourceCenter만)
   └─ GridUtility.IsInResourceExclusionZone() = true → isInResourceExclusionZone = true

5. 유닛 물리 충돌 (건설자 제외)
   └─ CheckCollision() = true → hasUnitCollision = true

6. 기본 유효성 판단
   └─ isOccupied || hasUnitCollision || isInResourceExclusionZone → Invalid

7. 사거리 계산
   └─ distanceToSurface = centerDistance - structureRadius

8. 비용 확인
   └─ UserCurrency.Amount < Cost → Invalid

9. 최종 상태 결정
   ├─ distanceToSurface ≤ WorkRange → ValidInRange (파란색)
   └─ distanceToSurface > WorkRange → ValidOutOfRange (노란색)
```

### UnitIntentState 변화 (이동 후 건설)

```
HandleBuildMoveRequestSystem: Intent.Build 설정
       ↓ (이동 중)
BuildArrivalSystem: Intent.Idle 복귀
```

---

## 시스템 실행 순서

```
[GhostInputSystemGroup - Client]
ConstructionMenuInputSystem → Q키 메뉴 처리, 건물 선택
UnitCommandInputSystem → 우클릭 명령
    ↓ UpdateAfter
StructurePlacementInputSystem → 좌클릭 시 RPC 전송 (MoveTarget 계산 포함)

[PresentationSystemGroup - Client]
StructurePreviewUpdateSystem → 그리드/자원노드구역/물리/비용 검증, PlacementStatus 결정

[SimulationSystemGroup - Server]
HandleBuildRequestSystem → 즉시 건설 (ValidateBuildRequestJob 병렬 + ExecuteBuildRequestJob 직렬)
    ↓ UpdateAfter: UnifiedTargetingSystem
HandleBuildMoveRequestSystem → 이동 후 건설 설정 (CompleteDependency 호출)
    ↓ UpdateAfter: MovementArrivalSystem
BuildArrivalSystem → 도착 시 건물 생성 (거리 검증 포함)
```

---

## 건설자 충돌 제외 로직

### 클라이언트 (StructurePreviewUpdateSystem.CheckCollision)

```csharp
// builderEntity를 직접 비교하여 제외
for (int i = 0; i < hits.Length; i++)
{
    Entity hitEntity = physicsWorld.PhysicsWorld.Bodies[hits[i]].Entity;

    // 건설자 제외
    if (builderEntity != Entity.Null && hitEntity == builderEntity)
    {
        continue; // 건설자는 충돌에서 제외
    }

    hasBlockingCollision = true;
    break;
}
```

### 서버 (ValidateBuildRequestJob.IsBuilder)

```csharp
// GhostId 기반 계층 탐색 (Parent 추적)
private bool IsBuilder(Entity hitEntity, int builderGhostId)
{
    if (builderGhostId == 0) return false;

    Entity current = hitEntity;
    for (int i = 0; i < 3; i++)  // 최대 3단계 Parent 탐색
    {
        if (current == Entity.Null) break;
        if (GhostInstanceLookup.HasComponent(current))
            return GhostInstanceLookup[current].ghostId == builderGhostId;
        if (ParentLookup.HasComponent(current))
            current = ParentLookup[current].Value;
        else break;
    }
    return false;
}
```

**CollisionFilter 설정:**
```csharp
Filter = new CollisionFilter
{
    BelongsTo = 1u << 7,           // Structure Layer
    CollidesWith = (1u << 11) | (1u << 12), // Unit | Enemy
    GroupIndex = 0
}
```

---

## 테크 상태 업데이트

ResourceCenter 건설 시 `UserTechState.HasResourceCenter = true` 설정:

```csharp
// HandleBuildRequestSystem.ExecuteBuildRequestJob
if (ResourceCenterTagLookup.HasComponent(request.PrefabEntity))
{
    UpdateTechState(request.SourceNetworkId, hasResourceCenter: true);
}

private void UpdateTechState(int networkId, bool hasResourceCenter)
{
    if (!NetworkIdToCurrencyMap.TryGetValue(networkId, out Entity userEconomyEntity))
        return;
    if (!UserTechStateLookup.HasComponent(userEconomyEntity))
        return;

    var techState = UserTechStateLookup[userEconomyEntity];
    techState.HasResourceCenter = hasResourceCenter;
    UserTechStateLookup[userEconomyEntity] = techState;
}

// BuildArrivalSystem.TryBuild
if (_resourceCenterTagLookup.HasComponent(structurePrefab))
{
    if (_userTechStateLookup.HasComponent(userCurrencyEntity))
    {
        var techState = _userTechStateLookup[userCurrencyEntity];
        techState.HasResourceCenter = true;
        _userTechStateLookup[userCurrencyEntity] = techState;
    }
}
```

---

## 도착 검증 로직 (BuildArrivalSystem)

```csharp
// 1. MovementWaypoints 비활성화 감지
if (waypointsEnabled.ValueRO)
    continue;

// 2. 거리 검증
float workRange = 1.0f;
if (_workRangeLookup.HasComponent(entity))
{
    workRange = _workRangeLookup[entity].Value;
}
float arrivalThreshold = workRange;

float centerDistance = math.distance(
    new float2(unitPos.x, unitPos.z),
    new float2(pending.BuildSiteCenter.x, pending.BuildSiteCenter.z)
);
float distanceToSurface = centerDistance - pending.StructureRadius;

if (distanceToSurface > arrivalThreshold)
    continue; // 아직 도착하지 않음
```
