# 유저 자원, 인구수

UserEconomy 베이킹 및 런타임 흐름

## 1. Unity Editor 설정 단계

### 1.1 UserEconomy 프리팹 생성

```
Assets/Prefabs/Economies/UserEconomy.prefab
├─ UserEconomyAuthoring (Authoring 컴포넌트)
│  ├─ initialCurrency: 100
│  ├─ initialCurrentPopulation: 0
│  └─ initialMaxPopulation: 300
└─ GhostAuthoringComponent (Netcode 동기화)
   ├─ Default Ghost Mode: Owner Predicted / Interpolated
   └─ Supported Ghost Modes: 선택
```

### 1.2 SubScene 참조 설정

```
SubScene (예: EntitiesSubScene)
└─ GameObject "UserEconomyPrefabRef"
   └─ UserEconomyPrefabRefAuthoring
      └─ playerEconomyPrefab: UserEconomy.prefab 할당
```

---

## 2. 베이킹 단계 (빌드/재생 시)

### 2.1 프리팹 베이킹

파일: `Authoring/Economy/UserEconomyAuthoring.cs`

```
UserEconomyAuthoring (GameObject)
       ↓ [Baker.Bake()]

Entity (프리팹 엔티티)
├─ UserEconomyTag        // 유저 경제 엔티티 식별 태그
├─ UserCurrency          // 자원 데이터
│  └─ Amount: 100
├─ UserSupply            // 인구수 데이터
│  ├─ Currentvalue: 0
│  └─ MaxValue: 300
├─ PopulationEvent (Buffer)  // 인구수 변경 이벤트 (사망 시 감소 처리용)
├─ UserTechState         // 기술 해금 상태
│  └─ HasResourceCenter: false
└─ [GhostComponent 자동 추가]
```

핵심 코드:
```csharp
// UserEconomyAuthoring.cs:21-49
Entity entity = GetEntity(TransformUsageFlags.None);

AddComponent<UserEconomyTag>(entity);

AddComponent(entity, new UserCurrency
{
    Amount = authoring.initialCurrency,
});

AddComponent(entity, new UserSupply
{
    Currentvalue = authoring.initialCurrentPopulation,
    MaxValue = authoring.initialMaxPopulation,
});

// 인구수 변경 이벤트 버퍼 (사망 시 감소 처리용)
AddBuffer<PopulationEvent>(entity);

AddComponent(entity, new UserTechState
{
    HasResourceCenter = false,
});
```

### 2.2 싱글톤 참조 베이킹

파일: `Authoring/CatalogAndRef/UserEconomyPrefabRefAuthoring.cs`

```
UserEconomyPrefabRefAuthoring (GameObject)
       ↓ [Baker.Bake()]

Entity (싱글톤 엔티티)
└─ UserEconomyPrefabRef
   └─ Prefab: UserEconomy 프리팹 엔티티
```

핵심 코드:
```csharp
// UserEconomyPrefabRefAuthoring.cs:25-33
Entity prefabEntity = GetEntity(authoring.playerEconomyPrefab, TransformUsageFlags.None);
Entity singleton = GetEntity(TransformUsageFlags.None);

AddComponent(singleton, new UserEconomyPrefabRef
{
    Prefab = prefabEntity
});
```

---

## 3. 런타임 단계

### 3.1 서버: 플레이어 접속 처리

파일: `Server/GoInGameServerSystem.cs`

```
클라이언트 접속
       ↓ [GoInGameRequestRpc 수신]

GoInGameServerSystem.OnUpdate()
       ↓

1. 싱글톤에서 프리팹 참조 가져오기
   var userEconomyPrefab = SystemAPI.GetSingleton<UserEconomyPrefabRef>().Prefab;
       ↓
2. UserEconomy 엔티티 인스턴스화
   Entity economyEntity = ECB.Instantiate(userEconomyPrefab);
       ↓
3. GhostOwner 추가 (유저 소유권 설정)
   ECB.AddComponent(economyEntity, new GhostOwner
   {
       NetworkId = networkId.Value  // 접속 ID (0, 1, 2...)
   });
```

핵심 코드:
```csharp
// GoInGameServerSystem.cs:28
var userEconomyPrefab = SystemAPI.GetSingleton<UserEconomyPrefabRef>().Prefab;

// GoInGameServerSystem.cs:73-77
Entity economyEntity = entityCommandBuffer.Instantiate(userEconomyPrefab);
entityCommandBuffer.AddComponent(economyEntity, new GhostOwner
{
    NetworkId = networkId.Value,
});
```

생성된 엔티티:
```
UserEconomy 런타임 엔티티
├─ UserEconomyTag
├─ UserCurrency { Amount: 100 }
├─ UserSupply { Currentvalue: 0, MaxValue: 300 }
├─ PopulationEvent (Buffer)  // 사망 시 감소 이벤트
├─ UserTechState { HasResourceCenter: false }
├─ GhostOwner { NetworkId: 0, 1, 2... }
└─ [Netcode 자동 컴포넌트들]
```

---

## 4. 네트워크 동기화 단계

### 4.1 서버 → 클라이언트 복제

```
[서버]
UserEconomy 엔티티 생성
       ↓ [Netcode for Entities 자동 동기화]

[클라이언트 월드]
UserEconomy 엔티티 복제
├─ UserEconomyTag
├─ UserCurrency (서버와 동일)
├─ UserSupply (서버와 동일)
├─ UserTechState (서버와 동일)
├─ GhostOwner { NetworkId: X }
└─ GhostOwnerIsLocal ← 소유자 클라이언트에만 자동 부착
```

**GhostOwnerIsLocal:**
- Netcode가 자동으로 추가하는 태그
- `GhostOwner.NetworkId == 로컬 플레이어 ID`일 때만 부착

---

## 5. 클라이언트: UI 표시

### 5.1 UI 렌더링

파일: `Client/Controller/UI/Info/UserResourceInfoRenderer.cs`

```
[MonoBehaviour Update]
       ↓

1. 쿼리 생성 (GhostOwnerIsLocal 필터링)
   CreateEntityQuery(
       UserCurrency,
       UserSupply,
       UserEconomyTag,
       GhostOwnerIsLocal  ← 자신의 자원만
   )
       ↓
2. 로컬 유저 경제 데이터 조회
   var currency = query.GetSingleton<UserCurrency>();
   var supply = query.GetSingleton<UserSupply>();
       ↓
3. UI 갱신 (Dirty Flag 최적화)
   if (cached != currency.Amount)
       userResourceInfoText.SetText("$: {0}", currency.Amount);
   if (cached != supply.Currentvalue)
       currentPopulationText.SetText("{0}", supply.Currentvalue);
   if (cached != supply.MaxValue)
       maxPopulationText.SetText("/ {0}", supply.MaxValue);
```

핵심 코드:
```csharp
// UserResourceInfoRenderer.cs:107-112
_userEconomyQuery = _clientEntityManager.CreateEntityQuery(
    ComponentType.ReadOnly<UserCurrency>(),
    ComponentType.ReadOnly<UserSupply>(),
    ComponentType.ReadOnly<UserEconomyTag>(),
    ComponentType.ReadOnly<GhostOwnerIsLocal>()  // 로컬 유저만
);

// UserResourceInfoRenderer.cs:58-59
var currency = _userEconomyQuery.GetSingleton<UserCurrency>();
var supply = _userEconomyQuery.GetSingleton<UserSupply>();
```

---

## 전체 흐름 요약

```
[Editor 설정]
1. UserEconomy 프리팹 생성 (UserEconomyAuthoring + GhostAuthoring)
2. SubScene에 UserEconomyPrefabRefAuthoring 배치 → 프리팹 할당

       ↓ [Play 버튼 / 빌드]

[베이킹]
3. UserEconomyAuthoring → UserCurrency + UserSupply + UserTechState + UserEconomyTag 컴포넌트로 변환
4. UserEconomyPrefabRefAuthoring → UserEconomyPrefabRef 싱글톤 생성

       ↓ [게임 실행]

[서버 런타임]
5. 플레이어 접속 → GoInGameServerSystem
6. UserEconomyPrefabRef.Prefab 인스턴스화
7. GhostOwner(NetworkId) 추가

       ↓ [Netcode 자동 동기화]

[클라이언트 런타임]
8. UserEconomy 엔티티 복제
9. 소유자 클라이언트에 GhostOwnerIsLocal 자동 부착

       ↓ [MonoBehaviour Update]

[UI 렌더링]
10. GhostOwnerIsLocal로 로컬 유저 경제만 쿼리
11. UI 갱신 (Dirty Flag로 최적화)
```

---

## 주요 컴포넌트 역할

| 컴포넌트 | 역할 | 위치 |
| --- | --- | --- |
| UserCurrency | 자원 데이터 (Amount) | Shared/Components/Data |
| UserSupply | 인구수 데이터 (Currentvalue, MaxValue) | Shared/Components/Data |
| PopulationEvent | 인구수 변경 이벤트 버퍼 (사망 시 감소) | Shared/Components/Events |
| UserTechState | 기술 해금 상태 (HasResourceCenter) | Shared/Components/Data |
| UserEconomyTag | 유저 경제 엔티티 식별 태그 | Shared/Components/Tags |
| UserEconomyPrefabRef | 프리팹 엔티티 참조 싱글톤 | Shared/Singletons/Ref |
| GhostOwner | 소유자 NetworkId (Netcode 표준) | Netcode 패키지 |
| GhostOwnerIsLocal | 로컬 소유 여부 (Netcode 자동) | Netcode 패키지 |

---

## 인구수(Population) 시스템

### 핵심 아키텍처

| 구분 | 시점 | 처리 방식 | 이유 |
|------|------|-----------|------|
| 생산 (증가) | **요청 시점** (Queue 등록) | `UserSupply` 직접 수정 | 연속 클릭 시 즉시 한도 초과 방지 |
| 사망 (감소) | 사망 시점 (체력 0) | `PopulationEvent` 버퍼 | 병렬 Job에서 안전하게 처리 |

**중요**: 인구수는 자원(Currency)과 동일하게 "예약제"로 처리. 생산 요청 시 즉시 증가시켜야 연속 클릭으로 인한 인구수 초과를 방지할 수 있음.

### 생산 시 (즉시 증가)

파일: `Server/Systems/Commands/Production/HandleProduceUnitRequestSystem.cs`

```
[1] Client → ProduceUnitRequestRpc → HandleProduceUnitRequestSystem
[2] 자원 검사 실패 → InsufficientFunds RPC
[3] 인구수 검사 실패 → PopulationLimitReached RPC
[4] 성공 → Currency 차감 + UserSupply.Currentvalue 즉시 증가 + ProductionQueue 활성화
```

핵심 코드:
```csharp
// 인구수 검사
if (!supplyRW.ValueRO.CanProduce(populationCost))
{
    // 인구수 초과 알림 RPC 전송
    var notifyEntity = ecb.CreateEntity();
    ecb.AddComponent(notifyEntity, new NotificationRpc { Type = NotificationType.PopulationLimitReached });
    ecb.AddComponent(notifyEntity, new SendRpcCommandRequest { TargetConnection = sourceConnection });
    return;
}

// [최종 승인] 자원 차감 + 인구수 즉시 증가 (예약)
currencyRW.ValueRW.Amount -= constructionCost;
supplyRW.ValueRW.Currentvalue += populationCost;
```

### 사망 시 (이벤트 버퍼)

**ServerDeathSystem.cs**:
```
[1] ServerDeathJob → ECB.AppendToBuffer(economyEntity, PopulationEvent{-popCost})
[2] EndSimulationEntityCommandBufferSystem → 버퍼에 이벤트 추가
```

**PopulationApplySystem.cs** (LateSimulationSystemGroup):
```
[3] PopulationApplyJob → 버퍼 소비 → UserSupply.Currentvalue 감소
```

핵심 코드:
```csharp
// ServerDeathJob (병렬)
if (popCost > 0 && NetworkIdToEconomyEntity.TryGetValue(ownerId, out Entity economyEntity))
{
    // Thread-Safe: ECB.AppendToBuffer 사용 (음수 Delta)
    Ecb.AppendToBuffer(sortKey, economyEntity, new PopulationEvent { Delta = -popCost });
}

// PopulationApplyJob (단일 스레드)
int totalDelta = 0;
for (int i = 0; i < events.Length; i++)
    totalDelta += events[i].Delta;

supply.Currentvalue += totalDelta;
if (supply.Currentvalue < 0) supply.Currentvalue = 0;
events.Clear();
```

### 시스템 실행 순서

```
SimulationSystemGroup (Server)
├─ HandleProduceUnitRequestSystem  → 인구수 검사 + 즉시 증가 (예약)
├─ ProductionProgressSystem        → 유닛 스폰 (인구수 변경 없음)
├─ ServerDeathSystem               → 유닛 사망, ECB.AppendToBuffer(-popCost)
└─ EndSimulationEntityCommandBufferSystem → ECB 명령 일괄 실행

LateSimulationSystemGroup (Server)
└─ PopulationApplySystem           → PopulationEvent 버퍼 소비, 인구수 감소 적용
```

---

## 자원 부족 / 인구수 초과 알림

### 전체 흐름

```
[클라이언트]                    [서버]                         [클라이언트]
건설/생산 요청 RPC 전송  →  자원/인구수 체크 실패  →  NotificationRpc 전송
                                                        ↓
                                            NotificationReceiveSystem
                                                        ↓
                                            NotificationState 싱글톤 업데이트
                                                        ↓
                                            ToastNotificationController (UI)
                                                        ↓
                                            "자원이 부족합니다!" / "인구수 초과!" 토스트 표시
```

### NotificationType

```csharp
public enum NotificationType : byte
{
    None = 0,
    InsufficientFunds = 1,      // 자원 부족
    InvalidPlacement = 2,        // 건설 위치 불가
    ProductionQueueFull = 3,     // 생산 대기열 가득 참
    PopulationLimitReached = 4,  // 인구수 초과
}
```

### 단계별 설명

#### 1. 서버: 자원 부족 감지 및 RPC 전송

**건설 시 (HandleBuildRequestSystem.cs):**
```csharp
if (currency.Amount < request.StructureCost)
{
    // 자원 부족 알림 RPC 전송
    var notifyEntity = Ecb.CreateEntity();
    Ecb.AddComponent(notifyEntity, new NotificationRpc { Type = NotificationType.InsufficientFunds });
    Ecb.AddComponent(notifyEntity, new SendRpcCommandRequest { TargetConnection = request.SourceConnection });

    Ecb.DestroyEntity(request.RpcEntity);
    continue;
}
```

**유닛 생산 시 (HandleProduceUnitRequestSystem.cs):**
```csharp
if (currencyRW.ValueRO.Amount < constructionCost)
{
    var notifyEntity = ecb.CreateEntity();
    ecb.AddComponent(notifyEntity, new NotificationRpc { Type = NotificationType.InsufficientFunds });
    ecb.AddComponent(notifyEntity, new SendRpcCommandRequest { TargetConnection = sourceConnection });
    return;
}
```

#### 2. 클라이언트: RPC 수신 (NotificationReceiveSystem.cs)

```csharp
foreach (var (rpc, rpcEntity) in
    SystemAPI.Query<RefRO<NotificationRpc>>()
        .WithAll<ReceiveRpcCommandRequest>()
        .WithEntityAccess())
{
    // NotificationState 싱글톤 업데이트
    notificationState.ValueRW.PendingNotification = rpc.ValueRO.Type;
    ecb.DestroyEntity(rpcEntity);
}
```

#### 3. 클라이언트: UI 표시 (ToastNotificationController.cs)

```csharp
// 매 프레임 싱글톤 확인
var notificationState = _notificationStateQuery.GetSingleton<NotificationState>();

if (notificationState.PendingNotification != NotificationType.None)
{
    ShowToast(notificationState.PendingNotification);  // "자원이 부족합니다!" 표시

    // 싱글톤 리셋
    _notificationStateQuery.SetSingleton(new NotificationState { PendingNotification = NotificationType.None });
}
```

### 요약 다이어그램

```
┌─────────────────┐
│  클라이언트     │
│  건설/생산 요청  │
└────────┬────────┘
         │ BuildRequestRpc / ProduceUnitRequestRpc
         ▼
┌─────────────────┐
│     서버        │
│  자원 체크      │
│  Amount < Cost? │
└────────┬────────┘
         │ Yes → NotificationRpc (InsufficientFunds)
         ▼
┌─────────────────┐
│  클라이언트     │
│  NotificationReceiveSystem
│       ↓         │
│  NotificationState.PendingNotification = InsufficientFunds
│       ↓         │
│  ToastNotificationController
│       ↓         │
│  "자원이 부족합니다!" 표시
└─────────────────┘
```
