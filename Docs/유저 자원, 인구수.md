# 유저 자원, 인구수

UserEconomy 베이킹 및 런타임 흐름

## 1. Unity Editor 설정 단계

### 1.1 UserEconomy 프리팹 생성

```
Assets/Prefabs/Economies/UserEconomy.prefab
├─ UserEconomyAuthoring (Authoring 컴포넌트)
│  ├─ initialCurrency: 100
│  ├─ initialCurrentPopulation: 0
│  └─ initialMaxPopulation: 300
└─ GhostAuthoringComponent (Netcode 동기화)
   ├─ Default Ghost Mode: Owner Predicted / Interpolated
   └─ Supported Ghost Modes: 선택
```

### 1.2 SubScene 참조 설정

```
SubScene (예: EntitiesSubScene)
└─ GameObject "UserEconomyPrefabRef"
   └─ UserEconomyPrefabRefAuthoring
      └─ playerEconomyPrefab: UserEconomy.prefab 할당
```

---

## 2. 베이킹 단계 (빌드/재생 시)

### 2.1 프리팹 베이킹

파일: `Authoring/Economy/UserEconomyAuthoring.cs`

```
UserEconomyAuthoring (GameObject)
       ↓ [Baker.Bake()]

Entity (프리팹 엔티티)
├─ UserEconomyTag        // 유저 경제 엔티티 식별 태그
├─ UserCurrency          // 자원 데이터
│  └─ Amount: 100
├─ UserSupply            // 인구수 데이터
│  ├─ Currentvalue: 0
│  └─ MaxValue: 300
│  └─ CanProduce(cost)   // 인구 여유 확인 메서드
├─ PopulationEvent (Buffer)  // 인구수 변경 이벤트 (사망 시 감소 처리용)
├─ UserTechState         // 기술 해금 상태
│  └─ HasResourceCenter: false
└─ [GhostComponent 자동 추가]
```

핵심 코드:
```csharp
// UserEconomyAuthoring.cs - Baker.Bake()
Entity entity = GetEntity(TransformUsageFlags.None);

// 플레이어 자원 식별 태그
AddComponent<UserEconomyTag>(entity);

// 자원 데이터
AddComponent(entity, new UserCurrency
{
    Amount = authoring.initialCurrency,
});

AddComponent(entity, new UserSupply
{
    Currentvalue = authoring.initialCurrentPopulation,
    MaxValue = authoring.initialMaxPopulation,
});

// 인구수 변경 이벤트 버퍼 (사망 시 감소 처리용)
AddBuffer<PopulationEvent>(entity);

// 테크 해금 상태 (초기: 모두 미해금)
AddComponent(entity, new UserTechState
{
    HasResourceCenter = false,
});
```

### 2.2 싱글톤 참조 베이킹

파일: `Authoring/CatalogAndRef/UserEconomyPrefabRefAuthoring.cs`

```
UserEconomyPrefabRefAuthoring (GameObject)
       ↓ [Baker.Bake()]

Entity (싱글톤 엔티티)
└─ UserEconomyPrefabRef
   └─ Prefab: UserEconomy 프리팹 엔티티
```

핵심 코드:
```csharp
// UserEconomyPrefabRefAuthoring.cs - Baker.Bake()
Entity prefabEntity = GetEntity(authoring.playerEconomyPrefab, TransformUsageFlags.None);
Entity singleton = GetEntity(TransformUsageFlags.None);

AddComponent(singleton, new UserEconomyPrefabRef
{
    Prefab = prefabEntity
});
```

---

## 3. 런타임 단계

### 3.1 서버: 플레이어 접속 처리

파일: `Server/GoInGameServerSystem.cs`

```
클라이언트 접속
       ↓ [GoInGameRequestRpc 수신]

GoInGameServerSystem.OnUpdate()
       ↓

1. 싱글톤에서 프리팹 참조 가져오기
   var userEconomyPrefab = SystemAPI.GetSingleton<UserEconomyPrefabRef>().Prefab;
       ↓
2. UserEconomy 엔티티 인스턴스화
   Entity economyEntity = ECB.Instantiate(userEconomyPrefab);
       ↓
3. GhostOwner 추가 (유저 소유권 설정)
   ECB.AddComponent(economyEntity, new GhostOwner
   {
       NetworkId = networkId.Value  // 접속 ID (0, 1, 2...)
   });
```

핵심 코드:
```csharp
// GoInGameServerSystem.cs - OnUpdate()
var userEconomyPrefab = SystemAPI.GetSingleton<UserEconomyPrefabRef>().Prefab;

// 플레이어 자원 엔티티 생성 (Ghost 프리팹 인스턴스화)
Entity economyEntity = entityCommandBuffer.Instantiate(userEconomyPrefab);
entityCommandBuffer.AddComponent(economyEntity, new GhostOwner
{
    NetworkId = networkId.Value,
});
```

생성된 엔티티:
```
UserEconomy 런타임 엔티티
├─ UserEconomyTag
├─ UserCurrency { Amount: 100 }
├─ UserSupply { Currentvalue: 0, MaxValue: 300 }
├─ PopulationEvent (Buffer)  // 사망 시 감소 이벤트
├─ UserTechState { HasResourceCenter: false }
├─ GhostOwner { NetworkId: 0, 1, 2... }
└─ [Netcode 자동 컴포넌트들]
```

---

## 4. 네트워크 동기화 단계

### 4.1 서버 → 클라이언트 복제

```
[서버]
UserEconomy 엔티티 생성
       ↓ [Netcode for Entities 자동 동기화]

[클라이언트 월드]
UserEconomy 엔티티 복제
├─ UserEconomyTag
├─ UserCurrency (서버와 동일)
├─ UserSupply (서버와 동일)
├─ UserTechState (서버와 동일)
├─ GhostOwner { NetworkId: X }
└─ GhostOwnerIsLocal ← 소유자 클라이언트에만 자동 부착
```

**GhostOwnerIsLocal:**
- Netcode가 자동으로 추가하는 태그
- `GhostOwner.NetworkId == 로컬 플레이어 ID`일 때만 부착

---

## 5. 클라이언트: UI 표시

### 5.1 UI 렌더링

파일: `Client/Controller/UI/Info/UserResourceInfoRenderer.cs`

```
[MonoBehaviour Update]
       ↓

1. 쿼리 생성 (GhostOwnerIsLocal 필터링)
   CreateEntityQuery(
       UserCurrency,
       UserSupply,
       UserEconomyTag,
       GhostOwnerIsLocal  ← 자신의 자원만
   )
       ↓
2. 엔티티 수 검증 (정확히 1개인지 확인)
   if (_userEconomyQuery.CalculateEntityCount() != 1)
       return; // GetSingleton 실패 방지
       ↓
3. 로컬 유저 경제 데이터 조회
   var currency = query.GetSingleton<UserCurrency>();
   var supply = query.GetSingleton<UserSupply>();
       ↓
4. UI 갱신 (Dirty Flag 최적화)
   if (cached != currency.Amount)
       userResourceInfoText.SetText("$: {0}", currency.Amount);
   if (cached != supply.Currentvalue)
       currentPopulationText.SetText("{0}", supply.Currentvalue);
   if (cached != supply.MaxValue)
       maxPopulationText.SetText("/ {0}", supply.MaxValue);
```

핵심 코드:
```csharp
// UserResourceInfoRenderer.cs - TryInitClientWorld()
_userEconomyQuery = _clientEntityManager.CreateEntityQuery(
    ComponentType.ReadOnly<UserCurrency>(),
    ComponentType.ReadOnly<UserSupply>(),
    ComponentType.ReadOnly<UserEconomyTag>(),
    ComponentType.ReadOnly<GhostOwnerIsLocal>()  // 로컬 유저만
);

// UserResourceInfoRenderer.cs - Update()
if (_userEconomyQuery.CalculateEntityCount() != 1)
{
    HidePanel();
    ResetCache();
    return;
}

var currency = _userEconomyQuery.GetSingleton<UserCurrency>();
var supply = _userEconomyQuery.GetSingleton<UserSupply>();
```

---

## 전체 흐름 요약

```
[Editor 설정]
1. UserEconomy 프리팹 생성 (UserEconomyAuthoring + GhostAuthoring)
2. SubScene에 UserEconomyPrefabRefAuthoring 배치 → 프리팹 할당

       ↓ [Play 버튼 / 빌드]

[베이킹]
3. UserEconomyAuthoring → UserCurrency + UserSupply + UserTechState + UserEconomyTag 컴포넌트로 변환
4. UserEconomyPrefabRefAuthoring → UserEconomyPrefabRef 싱글톤 생성

       ↓ [게임 실행]

[서버 런타임]
5. 플레이어 접속 → GoInGameServerSystem
6. UserEconomyPrefabRef.Prefab 인스턴스화
7. GhostOwner(NetworkId) 추가

       ↓ [Netcode 자동 동기화]

[클라이언트 런타임]
8. UserEconomy 엔티티 복제
9. 소유자 클라이언트에 GhostOwnerIsLocal 자동 부착

       ↓ [MonoBehaviour Update]

[UI 렌더링]
10. GhostOwnerIsLocal로 로컬 유저 경제만 쿼리
11. UI 갱신 (Dirty Flag로 최적화)
```

---

## 주요 컴포넌트 역할

| 컴포넌트 | 역할 | 파일 |
| --- | --- | --- |
| UserCurrency | 자원 데이터 (Amount) | `Shared/Components/Data/UserCurrency.cs` |
| UserSupply | 인구수 데이터 (Currentvalue, MaxValue, CanProduce()) | `Shared/Components/Data/UserPopulation.cs` |
| PopulationEvent | 인구수 변경 이벤트 버퍼 (사망 시 감소) | `Shared/Components/Events/PopulationEvent.cs` |
| UserTechState | 기술 해금 상태 (HasResourceCenter) | `Shared/Components/Data/UserTechState.cs` |
| UserEconomyTag | 유저 경제 엔티티 식별 태그 | `Shared/Components/Tags/UserEconomyTag.cs` |
| UserEconomyPrefabRef | 프리팹 엔티티 참조 싱글톤 | `Shared/Singletons/Ref/UserEconomyPrefabRef.cs` |
| GhostOwner | 소유자 NetworkId (Netcode 표준) | Netcode 패키지 |
| GhostOwnerIsLocal | 로컬 소유 여부 (Netcode 자동) | Netcode 패키지 |

---

## 인구수(Population) 시스템

### 핵심 아키텍처

| 구분 | 시점 | 처리 방식 | 이유 |
|------|------|-----------|------|
| 생산 (증가) | **요청 시점** (Queue 등록) | `UserSupply` 직접 수정 | 연속 클릭 시 즉시 한도 초과 방지 |
| 사망 (감소) | 사망 시점 (체력 0) | `PopulationEvent` 버퍼 | 병렬 Job에서 안전하게 처리 |

**중요**: 인구수는 자원(Currency)과 동일하게 "예약제"로 처리. 생산 요청 시 즉시 증가시켜야 연속 클릭으로 인한 인구수 초과를 방지할 수 있음.

### UserSupply 컴포넌트

파일: `Shared/Components/Data/UserPopulation.cs`

```csharp
[GhostComponent]
public struct UserSupply : IComponentData
{
    [GhostField] public int Currentvalue;
    [GhostField] public int MaxValue;

    // 편의를 위한 읽기 전용 메서드
    public readonly bool CanProduce(int cost) => Currentvalue + cost <= MaxValue;
}
```

### 생산 시 (즉시 증가)

파일: `Server/Systems/Commands/Production/HandleProduceUnitRequestSystem.cs`

```
[1] Client → ProduceUnitRequestRpc → HandleProduceUnitRequestSystem
[2] 자원 검사 실패 → InsufficientFunds RPC
[3] 인구수 검사 실패 → PopulationLimitReached RPC
[4] 성공 → Currency 차감 + UserSupply.Currentvalue 즉시 증가 + ProductionQueue 활성화
```

핵심 코드:
```csharp
// HandleProduceUnitRequestSystem.ProcessRequest()

// 인구수 검사 - UserSupply.CanProduce() 사용
if (!supplyRW.ValueRO.CanProduce(populationCost))
{
    // 인구수 초과 알림 RPC 전송
    var notifyEntity = ecb.CreateEntity();
    ecb.AddComponent(notifyEntity, new NotificationRpc { Type = NotificationType.PopulationLimitReached });
    ecb.AddComponent(notifyEntity, new SendRpcCommandRequest { TargetConnection = sourceConnection });
    return;
}

// [최종 승인] 자원 차감 + 인구수 즉시 증가 (예약)
currencyRW.ValueRW.Amount -= constructionCost;
supplyRW.ValueRW.Currentvalue += populationCost;
```

### 사망 시 (이벤트 버퍼)

**ServerDeathSystem.cs**:
```
[1] ServerDeathJob (병렬) → ECB.AppendToBuffer(economyEntity, PopulationEvent{-popCost})
[2] EndSimulationEntityCommandBufferSystem → 버퍼에 이벤트 추가
```

**PopulationApplySystem.cs** (LateSimulationSystemGroup):
```
[3] PopulationApplyJob → 버퍼 소비 → UserSupply.Currentvalue 감소
```

핵심 코드:
```csharp
// ServerDeathJob (병렬) - ServerDeathSystem.cs
if (popCost > 0 && NetworkIdToEconomyEntity.TryGetValue(ownerId, out Entity economyEntity))
{
    // Thread-Safe: ECB.AppendToBuffer 사용 (음수 Delta)
    Ecb.AppendToBuffer(sortKey, economyEntity, new PopulationEvent { Delta = -popCost });
}

// PopulationApplyJob - PopulationApplySystem.cs
int totalDelta = 0;
for (int i = 0; i < events.Length; i++)
    totalDelta += events[i].Delta;

supply.Currentvalue += totalDelta;

// 0 미만 방지
if (supply.Currentvalue < 0)
    supply.Currentvalue = 0;

events.Clear();
```

### 시스템 실행 순서

```
SimulationSystemGroup (Server)
├─ HandleProduceUnitRequestSystem  → 인구수 검사 + 즉시 증가 (예약)
├─ ProductionProgressSystem        → 유닛 스폰 (인구수 변경 없음)
├─ ServerDeathSystem               → 유닛 사망, ECB.AppendToBuffer(-popCost)
├─ TechStateRecalculateSystem      → ResourceCenter 파괴 시 테크 상태 재계산 (UpdateAfter ServerDeathSystem)
└─ EndSimulationEntityCommandBufferSystem → ECB 명령 일괄 실행

LateSimulationSystemGroup (Server)
└─ PopulationApplySystem           → PopulationEvent 버퍼 소비, 인구수 감소 적용
```

---

## 자원 부족 / 인구수 초과 알림

### 전체 흐름

```
[클라이언트]                    [서버]                         [클라이언트]
건설/생산 요청 RPC 전송  →  자원/인구수 체크 실패  →  NotificationRpc 전송
                                                        ↓
                                            NotificationReceiveSystem
                                                        ↓
                                            NotificationState 싱글톤 업데이트
                                                        ↓
                                            ToastNotificationController (UI)
                                                        ↓
                                            토스트 메시지 표시
```

### NotificationType

파일: `Shared/RPCs/NotificationRpc.cs`

```csharp
public enum NotificationType : byte
{
    None = 0,
    InsufficientFunds = 1,      // 자원 부족
    InvalidPlacement = 2,        // 건설 위치 불가
    ProductionQueueFull = 3,     // 생산 대기열 가득 참
    PopulationLimitReached = 4,  // 인구수 초과
}

public struct NotificationRpc : IRpcCommand
{
    public NotificationType Type;
}
```

### 단계별 설명

#### 1. 서버: 자원 부족 감지 및 RPC 전송

**건설 시 (HandleBuildRequestSystem.cs - ExecuteBuildRequestJob):**
```csharp
if (currency.Amount < request.StructureCost)
{
    // 자원 부족 알림 RPC 전송
    if (request.SourceConnection != Entity.Null)
    {
        var notifyEntity = Ecb.CreateEntity();
        Ecb.AddComponent(notifyEntity, new NotificationRpc { Type = NotificationType.InsufficientFunds });
        Ecb.AddComponent(notifyEntity, new SendRpcCommandRequest { TargetConnection = request.SourceConnection });
    }
    Ecb.DestroyEntity(request.RpcEntity);
    continue;
}
```

**빌더 건설 도착 시 (BuildArrivalSystem.cs):**
```csharp
if (currency.Amount < structureCost)
{
    // 자원 부족 알림 RPC 전송
    if (pending.SourceConnection != Entity.Null)
    {
        var notifyEntity = ecb.CreateEntity();
        ecb.AddComponent(notifyEntity, new NotificationRpc { Type = NotificationType.InsufficientFunds });
        ecb.AddComponent(notifyEntity, new SendRpcCommandRequest { TargetConnection = pending.SourceConnection });
    }
    return false;
}
```

**유닛 생산 시 (HandleProduceUnitRequestSystem.cs):**
```csharp
if (currencyRW.ValueRO.Amount < constructionCost)
{
    if (sourceConnection != Entity.Null)
    {
        var notifyEntity = ecb.CreateEntity();
        ecb.AddComponent(notifyEntity, new NotificationRpc { Type = NotificationType.InsufficientFunds });
        ecb.AddComponent(notifyEntity, new SendRpcCommandRequest { TargetConnection = sourceConnection });
    }
    return;
}
```

#### 2. 클라이언트: RPC 수신 (NotificationReceiveSystem.cs)

파일: `Client/Systems/NotificationReceiveSystem.cs`

```csharp
// OnCreate에서 싱글톤 생성
var entity = state.EntityManager.CreateEntity();
state.EntityManager.AddComponentData(entity, new NotificationState
{
    PendingNotification = NotificationType.None
});

// OnUpdate에서 RPC 수신 처리
foreach (var (rpc, rpcEntity) in
    SystemAPI.Query<RefRO<NotificationRpc>>()
        .WithAll<ReceiveRpcCommandRequest>()
        .WithEntityAccess())
{
    // NotificationState 싱글톤 업데이트 (TryGetSingletonRW 패턴)
    if (SystemAPI.TryGetSingletonRW<NotificationState>(out var notificationState))
    {
        notificationState.ValueRW.PendingNotification = rpc.ValueRO.Type;
    }

    ecb.DestroyEntity(rpcEntity);
}
```

#### 3. 클라이언트: UI 표시 (ToastNotificationController.cs)

파일: `Client/Controller/UI/ToastNotificationController.cs`

```csharp
// 매 프레임 싱글톤 확인
var notificationState = _notificationStateQuery.GetSingleton<NotificationState>();

if (notificationState.PendingNotification != NotificationType.None)
{
    ShowToast(notificationState.PendingNotification);

    // 싱글톤 리셋
    _notificationStateQuery.SetSingleton(new NotificationState
    {
        PendingNotification = NotificationType.None
    });
}

// 토스트 메시지 매핑
private string GetMessageForType(NotificationType type)
{
    return type switch
    {
        NotificationType.InsufficientFunds => "Not enough resources!",
        NotificationType.InvalidPlacement => "Invalid placement!",
        NotificationType.ProductionQueueFull => "Production queue full!",
        NotificationType.PopulationLimitReached => "Population limit reached!",
        _ => "Unknown error"
    };
}
```

### 요약 다이어그램

```
┌─────────────────┐
│  클라이언트     │
│  건설/생산 요청  │
└────────┬────────┘
         │ BuildRequestRpc / ProduceUnitRequestRpc
         ▼
┌─────────────────┐
│     서버        │
│  자원 체크      │
│  Amount < Cost? │
└────────┬────────┘
         │ Yes → NotificationRpc (InsufficientFunds / PopulationLimitReached)
         ▼
┌─────────────────┐
│  클라이언트     │
│  NotificationReceiveSystem
│       ↓         │
│  NotificationState.PendingNotification 업데이트
│       ↓         │
│  ToastNotificationController
│       ↓         │
│  토스트 메시지 표시
└─────────────────┘
```

---

## 테크 상태 시스템

### UserTechState 컴포넌트

파일: `Shared/Components/Data/UserTechState.cs`

```csharp
/// <summary>
/// 유저별 테크 해금 상태를 추적하는 컴포넌트
/// UserEconomy 엔티티에 함께 저장됨 (GhostOwner로 소유자 구분)
/// </summary>
[GhostComponent]
public struct UserTechState : IComponentData
{
    /// <summary>
    /// ResourceCenter 보유 여부 (Barracks 해금 조건)
    /// 서버에서 건물 생성/파괴 시 업데이트됨
    /// </summary>
    [GhostField] public bool HasResourceCenter;
}
```

### 테크 해금 (건설 시)

**HandleBuildRequestSystem.cs - ExecuteBuildRequestJob:**
```csharp
// ResourceCenter 건설 시 테크 상태 업데이트
if (ResourceCenterTagLookup.HasComponent(request.PrefabEntity))
{
    UpdateTechState(request.SourceNetworkId, hasResourceCenter: true);
}

private void UpdateTechState(int networkId, bool hasResourceCenter)
{
    if (!NetworkIdToCurrencyMap.TryGetValue(networkId, out Entity userEconomyEntity))
        return;

    if (!UserTechStateLookup.HasComponent(userEconomyEntity))
        return;

    var techState = UserTechStateLookup[userEconomyEntity];
    techState.HasResourceCenter = hasResourceCenter;
    UserTechStateLookup[userEconomyEntity] = techState;
}
```

**BuildArrivalSystem.cs:**
```csharp
// ResourceCenter 건설 시 테크 상태 업데이트
if (_resourceCenterTagLookup.HasComponent(structurePrefab))
{
    if (_userTechStateLookup.HasComponent(userCurrencyEntity))
    {
        var techState = _userTechStateLookup[userCurrencyEntity];
        techState.HasResourceCenter = true;
        _userTechStateLookup[userCurrencyEntity] = techState;
    }
}
```

### 테크 해금 취소 (건물 파괴 시)

파일: `Server/Systems/TechStateRecalculateSystem.cs`

```
[UpdateInGroup(typeof(SimulationSystemGroup))]
[UpdateAfter(typeof(ServerDeathSystem))]

ServerDeathSystem 이후에 실행되어:
1. Health <= 0인 ResourceCenter 감지
2. 해당 유저의 다른 살아있는 ResourceCenter 확인
3. 다른 ResourceCenter가 없으면 UserTechState.HasResourceCenter = false
```

핵심 코드:
```csharp
// 파괴 예정인 ResourceCenter 수집
var destroyedOwners = new NativeList<int>(Allocator.Temp);
foreach (var (health, ghostOwner) in SystemAPI.Query<RefRO<Health>, RefRO<GhostOwner>>()
             .WithAll<ResourceCenterTag>())
{
    if (health.ValueRO.CurrentValue <= 0)
    {
        destroyedOwners.Add(ghostOwner.ValueRO.NetworkId);
    }
}

// 살아있는 ResourceCenter 확인
var aliveOwners = new NativeHashSet<int>(16, Allocator.Temp);
foreach (var (health, ghostOwner) in SystemAPI.Query<RefRO<Health>, RefRO<GhostOwner>>()
             .WithAll<ResourceCenterTag>())
{
    if (health.ValueRO.CurrentValue > 0)
    {
        aliveOwners.Add(ghostOwner.ValueRO.NetworkId);
    }
}

// 유저별 테크 상태 업데이트
foreach (var (techState, ghostOwner) in SystemAPI.Query<RefRW<UserTechState>, RefRO<GhostOwner>>()
             .WithAll<UserEconomyTag>())
{
    int networkId = ghostOwner.ValueRO.NetworkId;

    // 파괴되었고, 다른 살아있는 것이 없으면 해금 취소
    if (wasDestroyed && !aliveOwners.Contains(networkId))
    {
        techState.ValueRW.HasResourceCenter = false;
    }
}
```

### 테크 상태 사용 (클라이언트)

파일: `Client/Utilities/BuildSelectionUtility.cs`

클라이언트에서 건물 메뉴 표시 시 UserTechState를 확인하여 해금된 건물만 활성화:

```csharp
// UserTechState 조회하여 건물 해금 상태 확인
if (_userTechStateQuery.CalculateEntityCount() == 1)
{
    var techState = _userTechStateQuery.GetSingleton<UserTechState>();
    // techState.HasResourceCenter로 Barracks 등 해금 조건 확인
}
```
