# 팀 색상 시스템

## 전체 흐름

```
[Baking] UnitAuthoring / StructureAuthoring / EnemyAuthoring
├─ Team { teamId = 0 } 부착 (부모 엔티티)
└─ URPMaterialPropertyBaseColor 부착 안 함 (런타임 처리)

[Runtime - Server] 유닛/건물 스폰 시
└─ Team.teamId = NetworkId.Value (1~8) 설정

[Runtime - Client] TeamColorSystem (매 프레임)
├─ Phase 1: 초기화 (새 메시 엔티티 감지)
│   ├─ MaterialMeshInfo + Parent + Without<TeamColorTarget> 쿼리
│   ├─ Parent 체인 탐색 → Team 보유 조상 엔티티 탐색
│   ├─ RenderMeshArray에서 원본 머티리얼 _BaseColor 읽기 → OriginalBaseColor 저장
│   └─ ECB로 TeamColorTarget + OriginalBaseColor + URPMaterialPropertyBaseColor 부착
│
└─ Phase 2: 색상 갱신 (IJobEntity, ScheduleParallel)
    ├─ TeamColorTarget.RootEntity → Team.teamId 조회
    └─ URPMaterialPropertyBaseColor = OriginalBaseColor * TeamColor (곱셈 블렌딩)

[Runtime - Client] StructurePreviewController (건설 프리뷰)
└─ 프리뷰 생성 시 sharedMaterial 원본 색상 × 팀 색상 곱셈 적용

[Runtime - Client] MinimapRenderer (미니맵)
└─ DrawTeamEntities: 엔티티별 Team.teamId → TeamColorPalette → 점 색상 결정
```

## 핵심 설계 포인트

1. **런타임 초기화**: Baker에서 자식 메시 엔티티에 `AddComponent` 불가 (DOTS Baking 제약). `TeamColorSystem`이 런타임에 `Parent` 체인 탐색 + ECB로 컴포넌트 부착
2. **프리팹 구조 대응**: "빈 부모(로직) + 자식(메시)" 구조에서 부모의 `URPMaterialPropertyBaseColor`는 렌더링에 영향 없음. 자식 메시 엔티티에 색상 적용 필수
3. **곱셈 블렌딩**: `최종 색상 = 원본 _BaseColor * 팀 색상`. 파츠별 색상/명암 차이를 유지하면서 팀 틴트 적용 (예: 회색 벽 × 빨강 = 어두운 빨강, 흰 지붕 × 빨강 = 밝은 빨강)
4. **빈 틴트 패턴**: teamId <= 0 (적, 씬 배치)은 `float4(1,1,1,1)` 반환 → 곱셈 결과가 원본 색상과 동일. 모든 경로에서 `TeamColorPalette.GetTeamColor()` 호출 (분기 없음)
5. **클라이언트 간 동일 색상**: `GhostOwnerIsLocal` 미사용. 모든 클라이언트가 `teamId` 기준으로 동일 색상 확인

---

## 클라이언트 시스템 (Client/Systems/)

| 파일 | 그룹 | 역할 |
| --- | --- | --- |
| TeamColorSystem.cs | SimulationSystemGroup (ClientSimulation) | Phase 1: 새 메시 엔티티에 TeamColorTarget + OriginalBaseColor + URPMaterialPropertyBaseColor 부착 (ECB). Phase 2: TeamColorJob(IJobEntity, ScheduleParallel)으로 원본*팀색상 곱셈 갱신 |

---

## 클라이언트 컨트롤러 (Client/Controller/)

| 파일 | 역할 |
| --- | --- |
| StructurePreviewController.cs | 건설 프리뷰 생성 시 `ApplyTeamColorTint()` 호출. 로컬 유저 teamId 조회 → `sharedMaterial` 원본 색상 × 팀 색상 곱셈 적용 |
| MinimapRenderer.cs | `DrawTeamEntities()`: 유닛/건물/히어로 엔티티별 Team.teamId 조회 → TeamColorPalette → 점 색상 결정. 적(RPC 데이터)은 별도 enemyColor 사용 |

---

## 컴포넌트 (Shared/Components/Data/)

| 파일 | 역할 |
| --- | --- |
| TeamColorTarget.cs | 자식 메시 엔티티 → 루트(Team 보유) 엔티티 참조. `Entity RootEntity` (Entity.Null이면 팀 미소속, 색상 갱신 스킵) |
| OriginalBaseColor.cs | 머티리얼 원본 `_BaseColor` 저장. 팀 색상과 곱셈하여 파츠별 색상/명암 차이 유지 |

---

## 유틸리티 (Shared/Utilities/)

| 파일 | 역할 |
| --- | --- |
| TeamColorPalette.cs | `GetTeamColor(int teamId)`: teamId → float4 색상 매핑. `[MethodImpl(AggressiveInlining)]`으로 Burst Job에서 인라인 가능. `[BurstCompile]` 미사용 (float4 반환 → BC1064 방지) |

---

## 색상 팔레트

| teamId | 대상 | 색상 | float4 |
|--------|------|------|--------|
| -1 | 적 | 빈 틴트 (원본 유지) | (1, 1, 1, 1) |
| 0 | 씬 배치 | 빈 틴트 (원본 유지) | (1, 1, 1, 1) |
| 1 | 유저 1 | 빨강 | (1.0, 0.3, 0.3, 1) |
| 2 | 유저 2 | 파랑 | (0.3, 0.6, 1.0, 1) |
| 3 | 유저 3 | 초록 | (0.3, 0.9, 0.3, 1) |
| 4 | 유저 4 | 노랑 | (1.0, 0.9, 0.2, 1) |
| 5 | 유저 5 | 주황 | (1.0, 0.6, 0.2, 1) |
| 6 | 유저 6 | 보라 | (0.7, 0.3, 1.0, 1) |
| 7 | 유저 7 | 시안 | (0.2, 0.9, 0.9, 1) |
| 8 | 유저 8 | 핑크 | (1.0, 0.5, 0.7, 1) |
| default | 범위 초과 | 빈 틴트 (원본 유지) | (1, 1, 1, 1) |

---

## TeamColorSystem 상세 로직

### Phase 1: 초기화 (InitializeNewMeshEntities)

```
새 메시 엔티티 감지 (MaterialMeshInfo + Parent + Without<TeamColorTarget>)
       ↓
Parent 체인 탐색 (최대 10단계)
       ├─ Team 컴포넌트 발견 → RootEntity = 해당 엔티티
       └─ Parent 없음 / 10단계 초과 → RootEntity = Entity.Null
       ↓
RenderMeshArray.GetMaterial()로 원본 _BaseColor 읽기
       ↓
ECB로 컴포넌트 부착
       ├─ TeamColorTarget { RootEntity } (항상)
       ├─ OriginalBaseColor { 원본 _BaseColor } (RootEntity != Entity.Null일 때만)
       └─ URPMaterialPropertyBaseColor { 원본 _BaseColor } (RootEntity != Entity.Null일 때만)
```

- **1회성 초기화**: `WithNone<TeamColorTarget>` 필터로 이미 처리된 엔티티 재처리 방지
- **원본 색상 보존**: `RenderMeshArray`에서 머티리얼의 `_BaseColor`를 읽어 `OriginalBaseColor`에 저장
- **Entity.Null 처리**: Team 미소속 메시(파티클, UI 등)에는 `URPMaterialPropertyBaseColor` 미부착 → 원본 머티리얼 유지

### Phase 2: 색상 갱신 (TeamColorJob)

```csharp
[BurstCompile]
public partial struct TeamColorJob : IJobEntity
{
    [ReadOnly] public ComponentLookup<Team> TeamLookup;

    void Execute(in TeamColorTarget target, in OriginalBaseColor original, ref URPMaterialPropertyBaseColor color)
    {
        if (target.RootEntity == Entity.Null) return;
        if (!TeamLookup.TryGetComponent(target.RootEntity, out Team team)) return;
        color.Value = original.Value * TeamColorPalette.GetTeamColor(team.teamId);
    }
}
```

- **ScheduleParallel**: 멀티스레드 실행. 2000+ 엔티티에서도 0.05ms 이하
- **매 프레임 갱신**: Team 변경, Ghost Relevancy 출현/소멸 자동 대응
- **안전한 Lookup**: `TryGetComponent`로 RootEntity 삭제 시 자동 스킵

---

## 건설 프리뷰 팀 색상

```
StructurePreviewController.UpdatePreviewVisuals()
       ↓ 프리팹 인덱스 변경 감지
프리뷰 GameObject Instantiate
       ↓
ApplyTeamColorTint()
       ├─ HeroTag + GhostOwnerIsLocal + Team 쿼리 → 로컬 유저 teamId
       └─ GetComponentsInChildren<MeshRenderer>()
              → sharedMaterial에서 원본 색상 읽기
              → renderer.material.SetColor("_BaseColor", originalColor * tint)
```

- **ECS가 아닌 GameObject**: 프리뷰는 ECS 엔티티가 아니므로 `TeamColorSystem` 대상이 아님. `MonoBehaviour`에서 직접 머티리얼 색상 설정
- **sharedMaterial/material 분리**: `sharedMaterial`에서 원본 색상 읽기, `material`(인스턴스)에 곱셈 결과 적용
- **Shader.PropertyToID 캐싱**: `BaseColorId` static readonly 필드로 문자열 해싱 1회만 수행

---

## 미니맵 팀 색상

```
MinimapRenderer.RenderMinimap()
       ↓
DrawTeamEntities(_unitQuery, 2)      // 유닛
DrawTeamEntities(_structureQuery, 3)  // 건물
DrawTeamEntities(_heroQuery, 4)       // 히어로
       ↓
각 엔티티별:
  Team.teamId 조회 → TeamColorPalette.GetTeamColor() → DrawDot()
```

- **적 (RPC)**: MinimapBatchRpc 데이터에는 teamId 없음 → 별도 `enemyColor` 필드 사용
- **자원 노드**: 팀 소속 아님 → `DrawEntities()`로 고정 `resourceColor` 사용

---

## Baker 제약과 런타임 초기화 패턴

### 문제

Baker에서 `GetEntity(childMeshRenderer, TransformUsageFlags.Renderable)`로 자식 메시 엔티티를 참조할 수 있지만, 해당 엔티티에 `AddComponent`를 호출하면 `InvalidOperationException: Entity doesn't belong to the current authoring component` 발생.

### 해결

Authoring에서는 부모 엔티티에 `Team`만 부착. 런타임 `TeamColorSystem`에서:

1. `MaterialMeshInfo` + `Parent` + `WithNone<TeamColorTarget>` 쿼리로 새 메시 엔티티 감지
2. `Parent` 체인을 순회하며 `Team` 컴포넌트를 가진 조상 엔티티 탐색
3. `RenderMeshArray`에서 원본 `_BaseColor` 읽어 `OriginalBaseColor`에 저장
4. ECB로 `TeamColorTarget` + `OriginalBaseColor` + `URPMaterialPropertyBaseColor` 부착

이 패턴은 자식 엔티티에 컴포넌트를 부착해야 하는 모든 상황에 재사용 가능.

---

## 시스템 실행 순서

```
[SimulationSystemGroup - Client]
TeamColorSystem
├─ InitializeNewMeshEntities (메인 스레드, ECB)
└─ TeamColorJob (ScheduleParallel)

[MonoBehaviour - Client]
StructurePreviewController.Update → ApplyTeamColorTint (프리뷰 생성 시)
MinimapRenderer.Update → DrawTeamEntities (0.1초 간격)
```
